<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SICK SLS Editor (Web)</title>
    <link rel="icon" type="image/png" href="/static/favicon.ico" />
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", "Yu Gothic UI", system-ui, -apple-system, sans-serif;
      }


      body {
        margin: 0;
        background: #eef1f5;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        background: #0b6fb8;
        color: #fff;
        padding: 1rem 1.5rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      header p {
        margin: 0.2rem 0 0;
      }

      main {
        width: 95%;
        margin: 2rem auto;
        padding: 1.5rem;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(15, 23, 42, 0.1);
        flex: 1;
        display: flex;
        gap: 1.5rem;
        align-items: flex-start;
      }

      .content-area {
        flex: 1 1 65%;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .side-menu {
        flex: 0 0 360px;
        max-height: calc(100vh - 4rem);
        overflow-y: auto;
        padding-right: 0.5rem;
        position: sticky;
        top: 2rem;
        align-self: flex-start;
      }

      .side-menu::-webkit-scrollbar {
        width: 6px;
      }

      .side-menu::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.25);
        border-radius: 3px;
      }

      .toolbar {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .toolbar-primary {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .toolbar-toggle {
        width: 100%;
        display: flex;
        justify-content: flex-start;
      }

      button,
      label.upload-btn,
      .inline-btn {
        border: none;
        border-radius: 6px;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        cursor: pointer;
        background: #0b6fb8;
        color: #fff;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        box-shadow: 0 1px 3px rgba(15, 23, 42, 0.2);
      }

      .legend-toggle-btn {
        background: #475569;
        font-size: 0.75rem;
        padding: 0.35rem 0.75rem;
        color: #e2e8f0;
      }

      button.secondary {
        background: #475569;
      }

      .inline-btn.inline-danger {
        background: #c53030;
      }
      label.upload-btn {
        position: relative;
      }

      label.upload-btn input[type="file"] {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      #status-text {
        margin-left: auto;
        font-size: 0.9rem;
        color: #475569;
      }

      #status-text[data-state="error"] {
        color: #c53030;
      }

      #status-text[data-state="warning"] {
        color: #d97706;
      }

      .plot-wrapper {
        width: 100%;
        max-width: none;
        min-height: 420px;
      }

      #plot {
        width: 100%;
        min-height: 520px;
        height: clamp(420px, 65vh, 900px);
      }

      .fieldset-filter {
        margin-top: 1rem;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.75rem;
        background: #f8fafc;
      }

      .fieldset-filter-controls {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      #fieldset-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
      }

      .fieldset-checkbox {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.9rem;
      }

      .triorb-shape-filter {
        margin-top: 1rem;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.75rem;
        background: #f1f5f9;
      }

      .triorb-shape-checkbox {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.9rem;
      }

      .side-menu {
        flex: 0 0 auto;
        min-width: 220px;
        max-width: 40%;
        width: fit-content;
        background: #f6f8fb;
        border-radius: 10px;
        padding: 1rem;
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
      }

      .side-menu h2 {
        font-size: 1rem;
        margin: 0 0 0.75rem;
        color: #1f2937;
      }

      .menu-section {
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 8px;
        margin-bottom: 0.5rem;
        background: #fff;
      }

      .menu-section summary {
        cursor: pointer;
        padding: 0.6rem 0.8rem;
        font-weight: 600;
        color: #0b6fb8;
        list-style: none;
      }

      .menu-section summary::-webkit-details-marker {
        display: none;
      }

      .menu-section summary::after {
        content: "+";
        float: right;
        font-weight: normal;
        color: #64748b;
      }

      .menu-section[open] summary::after {
        content: "-";
      }

      .menu-content {
        padding: 0.6rem 0.8rem 1rem;
        color: #475569;
        font-size: 0.9rem;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
      }

      .menu-description {
        margin: 0 0 0.6rem;
        color: #1f2937;
        font-weight: 500;
      }

      .menu-fileinfo-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 0.7rem 1rem;
      }

      .menu-fileinfo-field label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
      }

      .menu-fileinfo-field input {
        width: 100%;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        background: #fff;
      }

      .triorb-field label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
      }

      .triorb-field input,
      .triorb-field select {
        width: 100%;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        background: #e6f2ff;
      }

      .menu-fileinfo-field input:focus,
      .scanplane-card input:focus,
      .device-card input:focus,
      .fieldset-field input:focus,
      .field-attribute input:focus {
        outline: 2px solid rgba(11, 111, 184, 0.35);
        border-color: rgba(11, 111, 184, 0.65);
      }

      .scanplanes-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .scanplane-card,
      .device-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.6rem;
        background: #fefefe;
      }

      .scanplane-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: #0b6fb8;
        cursor: pointer;
      }

      .scanplane-details summary::-webkit-details-marker {
        display: none;
      }

      .scanplane-summary {
        font-size: 0.85rem;
        color: #475569;
      }

      .scanplane-fields,
      .device-fields {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.4rem 0.6rem;
      }

      .scanplane-field,
      .device-field {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .scanplane-field label,
      .device-field label {
        margin-bottom: 0.2rem;
        font-weight: 600;
        color: #475569;
      }

      .scanplane-field input,
      .device-field input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .device-card {
        margin-top: 0.5rem;
        background: #fff;
      }

      .device-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #334155;
        cursor: pointer;
      }

      .device-details summary::-webkit-details-marker {
        display: none;
      }

      .device-summary {
        font-size: 0.8rem;
        color: #64748b;
      }

      select {
        background: #e6f2ff;
      }

      .fieldsets-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .fieldset-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.6rem;
        background: #fff;
      }

      .fieldset-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .fieldset-details summary::-webkit-details-marker {
        display: none;
      }

      .fieldset-summary {
        font-size: 0.8rem;
        color: #475569;
        margin-left: 0.5rem;
      }

      .fieldset-fields,
      .field-attributes {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.5rem;
      }

      .fieldset-field,
      .field-attribute {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .debug-hidden {
        display: none !important;
      }

      body.debug-mode .debug-hidden {
        display: flex !important;
      }

      .fieldset-field label,
      .field-attribute label {
        margin-bottom: 0.2rem;
        font-weight: 600;
        color: #475569;
      }

      .fieldset-field input,
      .field-attribute input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .field-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.5rem;
        background: #fefefe;
        margin-top: 0.5rem;
      }

      .field-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .field-details summary::-webkit-details-marker {
        display: none;
      }

      .field-summary {
        font-size: 0.8rem;
        color: #64748b;
        margin-left: 0.5rem;
      }

      .shape-section {
        margin-top: 0.5rem;
      }

      .shape-list {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .triorb-shapes-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }

      .triorb-shape-card {
        border: 1px solid rgba(15, 23, 42, 0.15);
        border-radius: 10px;
        padding: 0.6rem;
        background: #f1f5f9;
      }

      .triorb-shape-card .shape-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .triorb-shape-card .shape-row label {
        margin: 0;
        font-weight: 600;
      }

      .triorb-shape-card .shape-details {
        margin-top: 0.6rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.4rem;
      }

      .triorb-shape-card input,
      .triorb-shape-card select {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.3rem 0.4rem;
      }

      .shape-entry {
        border: 1px dashed rgba(15, 23, 42, 0.2);
        border-radius: 6px;
        padding: 0.4rem 0.5rem;
        background: #f9fafb;
      }

      .shape-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
        color: #475569;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
      }

      .modal.active {
        display: flex;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
      }

      .modal-window {
        position: relative;
        background: #fff;
        border-radius: 12px;
        width: min(480px, 90vw);
        max-height: 85vh;
        overflow-y: auto;
        padding: 1rem;
        box-shadow: 0 10px 40px rgba(15, 23, 42, 0.35);
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
      }

      .modal-title {
        font-size: 1.1rem;
        font-weight: 700;
        color: #0f172a;
      }

      .modal-body {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .modal-footer {
        margin-top: 1rem;
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
      }

      .modal-field {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .modal-field input {
        width: 100%;
      }

      .shape-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        font-size: 0.75rem;
      }

      .shape-points {
        margin-top: 0.25rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        font-size: 0.8rem;
        color: #475569;
      }

      .shape-point {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        align-items: center;
      }

      .shape-point label {
        margin: 0;
        font-weight: 500;
      }

      .shape-point input {
        width: 5rem;
      }

      .fieldset-actions,
      .field-actions {
        margin-top: 0.5rem;
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
      }

      .shape-actions {
        margin-top: 0.5rem;
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
        justify-content: flex-start;
      }

      .fieldset-global-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.4rem 0.6rem;
      }

      .scanplane-actions {
        margin-top: 0.6rem;
        display: flex;
        justify-content: flex-end;
      }

      .device-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.4rem;
        font-weight: 600;
        color: #334155;
      }

      .shape-mini-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
      }

      footer {
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
        margin-bottom: 2rem;
      }

      @media (max-width: 960px) {
        main {
          flex-direction: column;
        }

        .side-menu {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div id="shape-modal" class="modal" aria-hidden="true">
      <div class="modal-backdrop" data-action="close-modal"></div>
      <div class="modal-window" role="dialog" aria-modal="true">
        <div class="modal-header">
          <span class="modal-title" id="shape-modal-title"></span>
          <button type="button" class="inline-btn inline-danger shape-mini-btn" id="shape-modal-close">
            Ã—
          </button>
        </div>
        <div class="modal-body" id="shape-modal-body"></div>
        <div class="modal-footer">
          <button type="button" class="inline-btn secondary" id="shape-modal-cancel">Cancel</button>
          <button type="button" class="inline-btn" id="shape-modal-save">Save</button>
        </div>
      </div>
    </div>
    <header>
      <h1>TriOrb - SICK SLS Editor</h1>
    </header>
    <main>
      <section class="content-area">
        <div class="toolbar">
          <div class="toolbar-primary">
            <button id="btn-new" type="button">New Plot</button>
        <button id="btn-save-triorb" type="button" class="secondary">Save (TriOrb)</button>
        <button id="btn-save-legacy" type="button" class="inline-btn">Save (SICK)</button>
            <label class="upload-btn">
              Load (XML)
              <input id="file-input" type="file" accept=".xml,.sgexml" />
            </label>
            <span id="status-text">Ready</span>
          </div>
          <div class="toolbar-toggle">
            <button id="btn-toggle-legend" type="button" class="legend-toggle-btn">Hide Legend</button>
          </div>
        </div>
        <div class="plot-wrapper">
          <div id="plot"></div>
        </div>
        <div class="fieldset-filter">
          <div class="fieldset-filter-controls">
            <button type="button" class="inline-btn" id="btn-fieldset-check-all">All check</button>
            <button type="button" class="inline-btn" id="btn-fieldset-uncheck-all">All uncheck</button>
          </div>
          <div id="fieldset-checkboxes"></div>
        </div>
        <div class="triorb-shape-filter">
          <div class="fieldset-filter-controls">
            <button type="button" class="inline-btn" id="btn-triorb-shape-check-all">Show All Shapes</button>
            <button type="button" class="inline-btn" id="btn-triorb-shape-uncheck-all">Hide All Shapes</button>
          </div>
          <div id="triorb-shape-checkboxes"></div>
        </div>
      </section>
      <aside class="side-menu">
        <h2>Structure Menu</h2>
        
        
        <details class="menu-section">
        
          <summary>FileInfo</summary>
          <div class="menu-content">
            
              <p class="menu-description">No additional attributes</p>
              
              <div class="menu-fileinfo-grid" data-scope="fileinfo">
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-ContentId">ContentId</label>
                  <input
                    id="fileinfo-ContentId"
                    type="text"
                    value="Scanner Complete Export"
                    data-field="ContentId"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-ContentVersion">ContentVersion</label>
                  <input
                    id="fileinfo-ContentVersion"
                    type="text"
                    value="1.6"
                    data-field="ContentVersion"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-Company">Company</label>
                  <input
                    id="fileinfo-Company"
                    type="text"
                    value="SICK AG"
                    data-field="Company"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationToolName">CreationToolName</label>
                  <input
                    id="fileinfo-CreationToolName"
                    type="text"
                    value="SAFETY DESIGNER ENGINEERING TOOL"
                    data-field="CreationToolName"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationToolVersion">CreationToolVersion</label>
                  <input
                    id="fileinfo-CreationToolVersion"
                    type="text"
                    value="2025.02"
                    data-field="CreationToolVersion"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationComponentName">CreationComponentName</label>
                  <input
                    id="fileinfo-CreationComponentName"
                    type="text"
                    value="nanoScan3"
                    data-field="CreationComponentName"
                  />
                </div>
                
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-CreationComponentVersion">CreationComponentVersion</label>
                  <input
                    id="fileinfo-CreationComponentVersion"
                    type="text"
                    value="1.19.23369.0"
                    data-field="CreationComponentVersion"
                  />
                </div>
                
              </div>
              
            
          </div>
        </details>
        
        
        <details class="menu-section" >
        
          <summary>Export_ScanPlanes</summary>
          <div class="menu-content">
            
              <p class="menu-description">No additional attributes</p>
              <button type="button" class="inline-btn" id="btn-add-scanplane">Add ScanPlane</button>
              <div class="scanplanes-editor" id="scanplanes-editor"></div>
            
          </div>
        </details>
        
        
        <details class="menu-section" >
        
          <summary>Export_FieldsetsAndFields</summary>
          <div class="menu-content">
            
              <p class="menu-description">No additional attributes</p>
              <button type="button" class="inline-btn" id="btn-add-fieldset">Add Fieldset</button>
              <details class="menu-section" id="fieldset-global-section">
                <summary>GlobalGeometry</summary>
                <div class="menu-content">
                  <div class="fieldset-global-grid" id="fieldset-global"></div>
                </div>
              </details>
              <details class="menu-section" id="fieldset-devices-section">
                <summary>Devices</summary>
                <div class="menu-content">
                  <div class="fieldset-actions">
                    <button type="button" class="inline-btn" id="btn-add-fieldset-device">
                      Add Device
                    </button>
                  </div>
                  <div class="fieldsets-editor" id="fieldset-devices"></div>
                </div>
              </details>
              <div class="fieldsets-editor" id="fieldsets-editor"></div>
            
          </div>
        </details>
        
        
        <details class="menu-section" >
        
          <summary>Export_CasetablesAndCases</summary>
          <div class="menu-content">
            
              <p>No additional attributes</p>
            
          </div>
        </details>
        
        <h2>TriOrb Menu</h2>
        <details class="menu-section">
          <summary>Device</summary>
          <div class="menu-content">
            <div class="menu-fileinfo-grid">
              <div class="triorb-field">
                <label>FieldOfView</label>
                <input
                  type="number"
                  id="triorb-field-of-view"
                  value="270"
                  min="1"
                  max="360"
                  step="1"
                />
              </div>
            </div>
          </div>
        </details>
        <details class="menu-section">
          <summary>Shapes</summary>
          <div class="menu-content">
            <div class="fieldset-actions">
              <button type="button" class="inline-btn" id="btn-add-triorb-shape">
                Add Shape
              </button>
            </div>
            <div class="triorb-shapes-list" id="triorb-shapes-list"></div>
          </div>
        </details>
        <details class="menu-section">
          <summary>Field</summary>
          <div class="menu-content">
            <div class="menu-fileinfo-grid">
              <div class="triorb-field">
                <label>MultipleSampling (2-16)</label>
                <input
                  id="global-multiple-sampling"
                  type="number"
                  min="2"
                  max="16"
                  value="2"
                />
              </div>
              <div class="triorb-field">
                <label>Resolution</label>
                <input
                  id="global-resolution"
                  type="number"
                  min="1"
                  max="1000"
                  value="70"
                />
              </div>
              <div class="triorb-field">
                <label>TolerancePositive</label>
                <input
                  id="global-tolerance-positive"
                  type="number"
                  value="0"
                />
              </div>
              <div class="triorb-field">
                <label>ToleranceNegative</label>
                <input
                  id="global-tolerance-negative"
                  type="number"
                  value="0"
                />
              </div>
            </div>
            <details class="menu-section">
              <summary>CommonCutOut #1</summary>
              <div class="menu-content">
                <ul>
                  <li>Polygon #1</li>
                  <li>Circle #1</li>
                  <li>Rectangle #1</li>
                </ul>
              </div>
            </details>
          </div>
        </details>
      </aside>
    </main>
    <footer>Flask + Plotly powered preview</footer>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const defaultFigure = {"data": [], "layout": {"legend": {"orientation": "h", "y": 1.02, "yanchor": "bottom"}, "margin": {"b": 60, "l": 60, "r": 20, "t": 30}, "paper_bgcolor": "#ffffff", "plot_bgcolor": "#ffffff", "shapes": [{"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": -750, "y1": -750, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -750, "x1": -750, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": -500, "y1": -500, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -500, "x1": -500, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": -250, "y1": -250, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -250, "x1": -250, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": 250, "y1": 250, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": 250, "x1": 250, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": 500, "y1": 500, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": 500, "x1": 500, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": -1000, "x1": 1000, "xref": "x", "y0": 750, "y1": 750, "yref": "y"}, {"line": {"color": "#cbd5f5", "dash": "dot", "width": 1}, "type": "line", "x0": 750, "x1": 750, "xref": "x", "y0": -1000, "y1": 1000, "yref": "y"}], "template": {"data": {"bar": [{"error_x": {"color": "#2a3f5f"}, "error_y": {"color": "#2a3f5f"}, "marker": {"line": {"color": "#E5ECF6", "width": 0.5}, "pattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}}, "type": "bar"}], "barpolar": [{"marker": {"line": {"color": "#E5ECF6", "width": 0.5}, "pattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}}, "type": "barpolar"}], "carpet": [{"aaxis": {"endlinecolor": "#2a3f5f", "gridcolor": "white", "linecolor": "white", "minorgridcolor": "white", "startlinecolor": "#2a3f5f"}, "baxis": {"endlinecolor": "#2a3f5f", "gridcolor": "white", "linecolor": "white", "minorgridcolor": "white", "startlinecolor": "#2a3f5f"}, "type": "carpet"}], "choropleth": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "type": "choropleth"}], "contour": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "contour"}], "contourcarpet": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "type": "contourcarpet"}], "heatmap": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "heatmap"}], "histogram": [{"marker": {"pattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}}, "type": "histogram"}], "histogram2d": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "histogram2d"}], "histogram2dcontour": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "histogram2dcontour"}], "mesh3d": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "type": "mesh3d"}], "parcoords": [{"line": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "parcoords"}], "pie": [{"automargin": true, "type": "pie"}], "scatter": [{"fillpattern": {"fillmode": "overlay", "size": 10, "solidity": 0.2}, "type": "scatter"}], "scatter3d": [{"line": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatter3d"}], "scattercarpet": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattercarpet"}], "scattergeo": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattergeo"}], "scattergl": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattergl"}], "scattermap": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattermap"}], "scattermapbox": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scattermapbox"}], "scatterpolar": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatterpolar"}], "scatterpolargl": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatterpolargl"}], "scatterternary": [{"marker": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "type": "scatterternary"}], "surface": [{"colorbar": {"outlinewidth": 0, "ticks": ""}, "colorscale": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "type": "surface"}], "table": [{"cells": {"fill": {"color": "#EBF0F8"}, "line": {"color": "white"}}, "header": {"fill": {"color": "#C8D4E3"}, "line": {"color": "white"}}, "type": "table"}]}, "layout": {"annotationdefaults": {"arrowcolor": "#2a3f5f", "arrowhead": 0, "arrowwidth": 1}, "autotypenumbers": "strict", "coloraxis": {"colorbar": {"outlinewidth": 0, "ticks": ""}}, "colorscale": {"diverging": [[0, "#8e0152"], [0.1, "#c51b7d"], [0.2, "#de77ae"], [0.3, "#f1b6da"], [0.4, "#fde0ef"], [0.5, "#f7f7f7"], [0.6, "#e6f5d0"], [0.7, "#b8e186"], [0.8, "#7fbc41"], [0.9, "#4d9221"], [1, "#276419"]], "sequential": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]], "sequentialminus": [[0.0, "#0d0887"], [0.1111111111111111, "#46039f"], [0.2222222222222222, "#7201a8"], [0.3333333333333333, "#9c179e"], [0.4444444444444444, "#bd3786"], [0.5555555555555556, "#d8576b"], [0.6666666666666666, "#ed7953"], [0.7777777777777778, "#fb9f3a"], [0.8888888888888888, "#fdca26"], [1.0, "#f0f921"]]}, "colorway": ["#636efa", "#EF553B", "#00cc96", "#ab63fa", "#FFA15A", "#19d3f3", "#FF6692", "#B6E880", "#FF97FF", "#FECB52"], "font": {"color": "#2a3f5f"}, "geo": {"bgcolor": "white", "lakecolor": "white", "landcolor": "#E5ECF6", "showlakes": true, "showland": true, "subunitcolor": "white"}, "hoverlabel": {"align": "left"}, "hovermode": "closest", "mapbox": {"style": "light"}, "paper_bgcolor": "white", "plot_bgcolor": "#E5ECF6", "polar": {"angularaxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}, "bgcolor": "#E5ECF6", "radialaxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}}, "scene": {"xaxis": {"backgroundcolor": "#E5ECF6", "gridcolor": "white", "gridwidth": 2, "linecolor": "white", "showbackground": true, "ticks": "", "zerolinecolor": "white"}, "yaxis": {"backgroundcolor": "#E5ECF6", "gridcolor": "white", "gridwidth": 2, "linecolor": "white", "showbackground": true, "ticks": "", "zerolinecolor": "white"}, "zaxis": {"backgroundcolor": "#E5ECF6", "gridcolor": "white", "gridwidth": 2, "linecolor": "white", "showbackground": true, "ticks": "", "zerolinecolor": "white"}}, "shapedefaults": {"line": {"color": "#2a3f5f"}}, "ternary": {"aaxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}, "baxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}, "bgcolor": "#E5ECF6", "caxis": {"gridcolor": "white", "linecolor": "white", "ticks": ""}}, "title": {"x": 0.05}, "xaxis": {"automargin": true, "gridcolor": "white", "linecolor": "white", "ticks": "", "title": {"standoff": 15}, "zerolinecolor": "white", "zerolinewidth": 2}, "yaxis": {"automargin": true, "gridcolor": "white", "linecolor": "white", "ticks": "", "title": {"standoff": 15}, "zerolinecolor": "white", "zerolinewidth": 2}}}, "xaxis": {"constrain": "range", "dtick": 100, "gridcolor": "#d9dee7", "gridwidth": 1, "linecolor": "#6b7a99", "linewidth": 2, "minor": {"dtick": 50, "gridcolor": "#f2f5fb", "gridwidth": 0.5, "showgrid": true}, "range": [-1000, 1000], "showgrid": true, "showline": true, "tick0": 0, "title": {"text": "X[mm]"}, "zeroline": true, "zerolinecolor": "#9fb3d1", "zerolinewidth": 2}, "yaxis": {"constrain": "range", "dtick": 100, "gridcolor": "#d9dee7", "gridwidth": 1, "linecolor": "#6b7a99", "linewidth": 2, "minor": {"dtick": 50, "gridcolor": "#f2f5fb", "gridwidth": 0.5, "showgrid": true}, "range": [-1000, 1000], "scaleanchor": "x", "scaleratio": 1, "showgrid": true, "showline": true, "tick0": 0, "title": {"text": "Y[mm]"}, "zeroline": true, "zerolinecolor": "#9fb3d1", "zerolinewidth": 2}}};
        defaultFigure.data = defaultFigure.data || [];
        const rootAttributes = {"Commentary": "", "Hash": "0835FD278D7CC3C3C7CF2A2872DA772020A46E3D1E4B6FF93D5FC242CB2EA042CB9F33C38E4006EA160A969DA725A1134AC8FE5A45A87380DBC5C998B757CB5F", "Timestamp": "2025-11-11T01:58:44.6531564Z"};
        const initialScanPlanes = [{"attributes": {"Index": "0", "MultipleSampling": "2", "MultipleSamplingOff2OnActivated": "false", "Name": "Monitoring plane 1", "ObjectSize": "70", "ScanPlaneDirection": "Horizontal", "SelectedCaseSwitching": "Fast", "UseReferenceContour": "false"}, "devices": [{"attributes": {"DeviceName": "Right", "Index": "0", "ResponseTime": "30", "ScanResolutionAddition": "0", "Typekey": "NANS3-CAAZ30ZA1P02", "TypekeyDisplayVersion": "V 1.0.0", "TypekeyVersion": "1.0"}}]}];
        const fieldsetData = {"devices": [{"attributes": {"PositionX": "170", "PositionY": "156", "Rotation": "290", "StandingUpsideDown": "true", "Typekey": "NANS3-CAAZ30ZA1P02", "TypekeyDisplayVersion": "V 1.0.0", "TypekeyVersion": "1.0"}}], "fieldsets": [{"attributes": {"Name": "\u53f30.65", "NameLatin9Key": "_FSN000_9516"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-f3c9f8c6"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-89be8384"}]}]}, {"attributes": {"Name": "\u53f3\u524d0.65", "NameLatin9Key": "_FSN001_2740"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-d245e03c"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-c63f8bfd"}]}]}, {"attributes": {"Name": "\u524d0.65", "NameLatin9Key": "_FSN002_363F"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-03fdedf5"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-7b81c71a"}]}]}, {"attributes": {"Name": "\u5de6\u524d0.65", "NameLatin9Key": "_FSN003_D5B2"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-0b64a33d"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-cac04ef4"}]}]}, {"attributes": {"Name": "\u5de60.65", "NameLatin9Key": "_FSN004_EE1F"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-5d29e876"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-9aa6ccb0"}]}]}, {"attributes": {"Name": "\u5de6\u5f8c0.65", "NameLatin9Key": "_FSN005_528B"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-5b35c961"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-3d1e1856"}]}]}, {"attributes": {"Name": "\u5f8c0.65", "NameLatin9Key": "_FSN006_B106"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-1146fc79"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-d30a3b3d"}]}]}, {"attributes": {"Name": "\u53f3\u5f8c0.65", "NameLatin9Key": "_FSN007_A079"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-5c354162"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-b2cb2e98"}]}]}, {"attributes": {"Name": "\u53f30.3", "NameLatin9Key": "_FSN008_D438"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-d4c558c2"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-40e41b95"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-ba04d30f"}]}]}, {"attributes": {"Name": "\u53f3\u524d0.3", "NameLatin9Key": "_FSN009_4381"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-85319026"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-dada42e9"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-4661e771"}]}]}, {"attributes": {"Name": "\u524d0.3", "NameLatin9Key": "_FSN010_3CBD"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-a21507a6"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-b6dfa23b"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-aaa4c98c"}]}]}, {"attributes": {"Name": "\u5de6\u524d0.3", "NameLatin9Key": "_FSN011_30C7"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-9a7ad549"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-1c55e02c"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-ac8ba56d"}]}]}, {"attributes": {"Name": "\u5de60.3", "NameLatin9Key": "_FSN012_1D9D"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-b1195069"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-c5123045"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-aa762fc1"}]}]}, {"attributes": {"Name": "\u5de6\u5f8c0.3", "NameLatin9Key": "_FSN013_0833"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-903069eb"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-42f41ead"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-46a1d468"}]}]}, {"attributes": {"Name": "\u5f8c0.3", "NameLatin9Key": "_FSN014_0449"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-9afbfdac"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-8aa07212"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-1943c2a4"}]}]}, {"attributes": {"Name": "\u53f3\u5f8c0.3", "NameLatin9Key": "_FSN015_7B75"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-304c41d1"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed down", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-ab5bbac7"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-642d2586"}]}]}, {"attributes": {"Name": "\u53f30.15", "NameLatin9Key": "_FSN016_A514"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-3c5070bd"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-a7fdd216"}]}]}, {"attributes": {"Name": "\u53f3\u524d0.15", "NameLatin9Key": "_FSN017_1742"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-d9f1df83"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-ff6b0afc"}]}]}, {"attributes": {"Name": "\u524d0.15", "NameLatin9Key": "_FSN018_063D"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-1f8f9857"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-fdc6b054"}]}]}, {"attributes": {"Name": "\u5de6\u524d0.15", "NameLatin9Key": "_FSN019_E5B0"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-f2b041f4"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-e845f2ef"}]}]}, {"attributes": {"Name": "\u5de60.15", "NameLatin9Key": "_FSN020_DE1D"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-ef93506e"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-33910a95"}]}]}, {"attributes": {"Name": "\u5de6\u5f8c0.15", "NameLatin9Key": "_FSN021_6289"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-f7585b29"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-3b094552"}]}]}, {"attributes": {"Name": "\u5f8c0.15", "NameLatin9Key": "_FSN022_8104"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-8762e3dd"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-d1e78034"}]}]}, {"attributes": {"Name": "\u53f3\u5f8c0.15", "NameLatin9Key": "_FSN023_907B"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-54a8e8e9"}]}, {"attributes": {"Fieldtype": "WarningSafeBlanking", "MultipleSampling": "2", "Name": "Speed up", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-2837d67e"}]}]}, {"attributes": {"Name": "\u56de\u8ee2", "NameLatin9Key": "_FSN024_7C2F"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "2", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-6be1a623"}, {"shapeId": "shape-48390845"}]}]}, {"attributes": {"Name": "Stop(minimum)"}, "fields": [{"attributes": {"Fieldtype": "ProtectiveSafeBlanking", "MultipleSampling": "4", "Name": "Protective", "Resolution": "70", "ToleranceNegative": "0", "TolerancePositive": "0"}, "shapeRefs": [{"shapeId": "shape-44a93288"}, {"shapeId": "shape-9723422d"}, {"shapeId": "shape-5c45a7d5"}, {"shapeId": "shape-6be78c0c"}, {"shapeId": "shape-05b6c553"}, {"shapeId": "shape-b27e3efe"}]}]}], "global_geometry": {"UseGlobalGeometry": "false"}};
        const initialFieldsets = fieldsetData.fieldsets || [];
        const initialFieldsetDevices = fieldsetData.devices || [];
        const initialFieldsetGlobal = fieldsetData.global_geometry || {};

        const figureConfig = { responsive: true, displaylogo: false };
        const fieldsetColorPalette = [
          "#2563eb",
          "#f43f5e",
          "#10b981",
          "#f97316",
          "#c084fc",
          "#14b8a6",
          "#facc15",
          "#8b5cf6",
        ];
        const circleSampleSegments = 72;
        const legendLabelMaxLength = 36;
        const defaultScanDeviceTemplates = [
          { DeviceName: "Right" },
          { DeviceName: "Left" },
        ];
        const defaultFieldsetDeviceTemplates = [
          { PositionX: "170", PositionY: "156", Rotation: "290", StandingUpsideDown: "true" },
          { PositionX: "-170", PositionY: "156", Rotation: "70", StandingUpsideDown: "true" },
        ];
        const shapeTypeOptions = {
          polygon: ["CutOut", "Field"],
          rectangle: ["Field"],
          circle: ["Field"],
        };
        const plotNode = document.getElementById("plot");
        const statusText = document.getElementById("status-text");
        const fileInput = document.getElementById("file-input");
        const plotWrapper = document.querySelector(".plot-wrapper");
        const scanPlanesContainer = document.getElementById("scanplanes-editor");
        const addScanPlaneBtn = document.getElementById("btn-add-scanplane");
        const fieldsetsContainer = document.getElementById("fieldsets-editor");
        const fieldsetDevicesContainer = document.getElementById("fieldset-devices");
        const addFieldsetDeviceBtn = document.getElementById("btn-add-fieldset-device");
        const fieldsetGlobalContainer = document.getElementById("fieldset-global");
        const addFieldsetBtn = document.getElementById("btn-add-fieldset");
        const globalMultipleSamplingInput = document.getElementById("global-multiple-sampling");
        const fieldsetCheckboxes = document.getElementById("fieldset-checkboxes");
        const checkAllBtn = document.getElementById("btn-fieldset-check-all");
        const uncheckAllBtn = document.getElementById("btn-fieldset-uncheck-all");
        const toggleLegendBtn = document.getElementById("btn-toggle-legend");
        const fieldOfViewInput = document.getElementById("triorb-field-of-view");
        const globalResolutionInput = document.getElementById("global-resolution");
        const globalTolerancePositiveInput = document.getElementById("global-tolerance-positive");
        const globalToleranceNegativeInput = document.getElementById("global-tolerance-negative");
        const triorbShapesContainer = document.getElementById("triorb-shapes-list");
        const addTriOrbShapeBtn = document.getElementById("btn-add-triorb-shape");
        const triorbShapeCheckboxes = document.getElementById("triorb-shape-checkboxes");
        const triorbShapeCheckAllBtn = document.getElementById("btn-triorb-shape-check-all");
        const triorbShapeUncheckAllBtn = document.getElementById("btn-triorb-shape-uncheck-all");
        const initialTriOrbShapes = [{"id": "shape-6be1a623", "name": "\u53f30.65 Protective Polygon", "polygon": {"Type": "CutOut", "points": [{"X": "0", "Y": "245"}, {"X": "170", "Y": "156"}, {"X": "0", "Y": "-299"}, {"X": "-170", "Y": "156"}]}, "type": "Polygon"}, {"id": "shape-f3c9f8c6", "name": "\u53f30.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-200", "OriginY": "464", "Rotation": "0", "Type": "Field", "Width": "950"}, "type": "Rectangle"}, {"id": "shape-89be8384", "name": "\u53f30.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-200", "OriginY": "512", "Rotation": "0", "Type": "Field", "Width": "1600"}, "type": "Rectangle"}, {"id": "shape-d245e03c", "name": "\u53f3\u524d0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-325", "OriginY": "329", "Rotation": "45", "Type": "Field", "Width": "826"}, "type": "Rectangle"}, {"id": "shape-c63f8bfd", "name": "\u53f3\u524d0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-361", "OriginY": "363", "Rotation": "45", "Type": "Field", "Width": "1474"}, "type": "Rectangle"}, {"id": "shape-03fdedf5", "name": "\u524d0.65 Protective Rectangle", "rectangle": {"Height": "950", "OriginX": "-462", "OriginY": "750", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"id": "shape-7b81c71a", "name": "\u524d0.65 Speed down Rectangle", "rectangle": {"Height": "1600", "OriginX": "-512", "OriginY": "1400", "Rotation": "0", "Type": "Field", "Width": "1024"}, "type": "Rectangle"}, {"id": "shape-0b64a33d", "name": "\u5de6\u524d0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-268", "OriginY": "916", "Rotation": "315", "Type": "Field", "Width": "839"}, "type": "Rectangle"}, {"id": "shape-cac04ef4", "name": "\u5de6\u524d0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-682", "OriginY": "1404", "Rotation": "315", "Type": "Field", "Width": "1477"}, "type": "Rectangle"}, {"id": "shape-5d29e876", "name": "\u5de60.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-750", "OriginY": "462", "Rotation": "0", "Type": "Field", "Width": "950"}, "type": "Rectangle"}, {"id": "shape-9aa6ccb0", "name": "\u5de60.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-1400", "OriginY": "512", "Rotation": "0", "Type": "Field", "Width": "1600"}, "type": "Rectangle"}, {"id": "shape-5b35c961", "name": "\u5de6\u5f8c0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "-916", "OriginY": "-262", "Rotation": "45", "Type": "Field", "Width": "833"}, "type": "Rectangle"}, {"id": "shape-3d1e1856", "name": "\u5de6\u5f8c0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "-1407", "OriginY": "-687", "Rotation": "45", "Type": "Field", "Width": "1481"}, "type": "Rectangle"}, {"id": "shape-1146fc79", "name": "\u5f8c0.65 Protective Rectangle", "rectangle": {"Height": "950", "OriginX": "-462", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"id": "shape-d30a3b3d", "name": "\u5f8c0.65 Speed down Rectangle", "rectangle": {"Height": "1600", "OriginX": "-512", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "1024"}, "type": "Rectangle"}, {"id": "shape-5c354162", "name": "\u53f3\u5f8c0.65 Protective Rectangle", "rectangle": {"Height": "924", "OriginX": "325", "OriginY": "325", "Rotation": "315", "Type": "Field", "Width": "830"}, "type": "Rectangle"}, {"id": "shape-b2cb2e98", "name": "\u53f3\u5f8c0.65 Speed down Rectangle", "rectangle": {"Height": "1024", "OriginX": "361", "OriginY": "361", "Rotation": "315", "Type": "Field", "Width": "1486"}, "type": "Rectangle"}, {"id": "shape-d4c558c2", "name": "\u53f30.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-200", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "750"}, "type": "Rectangle"}, {"id": "shape-40e41b95", "name": "\u53f30.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-200", "OriginY": "412", "Rotation": "0", "Type": "Field", "Width": "1200"}, "type": "Rectangle"}, {"id": "shape-ba04d30f", "name": "\u53f30.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-200", "OriginY": "562", "Rotation": "0", "Type": "Field", "Width": "1700"}, "type": "Rectangle"}, {"id": "shape-85319026", "name": "\u53f3\u524d0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-257", "OriginY": "257", "Rotation": "45", "Type": "Field", "Width": "634"}, "type": "Rectangle"}, {"id": "shape-dada42e9", "name": "\u53f3\u524d0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-291", "OriginY": "291", "Rotation": "45", "Type": "Field", "Width": "1078"}, "type": "Rectangle"}, {"id": "shape-4661e771", "name": "\u53f3\u524d0.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-396", "OriginY": "396", "Rotation": "45", "Type": "Field", "Width": "1579"}, "type": "Rectangle"}, {"id": "shape-a21507a6", "name": "\u524d0.3 Protective Rectangle", "rectangle": {"Height": "750", "OriginX": "-362", "OriginY": "550", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"id": "shape-b6dfa23b", "name": "\u524d0.3 Speed down Rectangle", "rectangle": {"Height": "1200", "OriginX": "-412", "OriginY": "1000", "Rotation": "0", "Type": "Field", "Width": "824"}, "type": "Rectangle"}, {"id": "shape-aaa4c98c", "name": "\u524d0.3 Speed up Rectangle", "rectangle": {"Height": "1700", "OriginX": "-562", "OriginY": "1500", "Rotation": "0", "Type": "Field", "Width": "1124"}, "type": "Rectangle"}, {"id": "shape-9a7ad549", "name": "\u5de6\u524d0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-195", "OriginY": "705", "Rotation": "315", "Type": "Field", "Width": "635"}, "type": "Rectangle"}, {"id": "shape-1c55e02c", "name": "\u5de6\u524d0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-456", "OriginY": "1040", "Rotation": "315", "Type": "Field", "Width": "1058"}, "type": "Rectangle"}, {"id": "shape-ac8ba56d", "name": "\u5de6\u524d0.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-629", "OriginY": "1421", "Rotation": "315", "Type": "Field", "Width": "1451"}, "type": "Rectangle"}, {"id": "shape-b1195069", "name": "\u5de60.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-550", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "750"}, "type": "Rectangle"}, {"id": "shape-c5123045", "name": "\u5de60.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-1000", "OriginY": "412", "Rotation": "0", "Type": "Field", "Width": "1200"}, "type": "Rectangle"}, {"id": "shape-aa762fc1", "name": "\u5de60.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-1500", "OriginY": "562", "Rotation": "0", "Type": "Field", "Width": "1700"}, "type": "Rectangle"}, {"id": "shape-903069eb", "name": "\u5de6\u5f8c0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-699", "OriginY": "-191", "Rotation": "45", "Type": "Field", "Width": "629"}, "type": "Rectangle"}, {"id": "shape-42f41ead", "name": "\u5de6\u5f8c0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "-1058", "OriginY": "-474", "Rotation": "45", "Type": "Field", "Width": "1084"}, "type": "Rectangle"}, {"id": "shape-46a1d468", "name": "\u5de6\u5f8c0.3 Speed up Rectangle", "rectangle": {"Height": "1124", "OriginX": "-1519", "OriginY": "-721", "Rotation": "45", "Type": "Field", "Width": "1585"}, "type": "Rectangle"}, {"id": "shape-9afbfdac", "name": "\u5f8c0.3 Protective Rectangle", "rectangle": {"Height": "750", "OriginX": "-362", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"id": "shape-8aa07212", "name": "\u5f8c0.3 Speed down Rectangle", "rectangle": {"Height": "1200", "OriginX": "-412", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "824"}, "type": "Rectangle"}, {"id": "shape-1943c2a4", "name": "\u5f8c0.3 Speed up Rectangle", "rectangle": {"Height": "1700", "OriginX": "-562", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "1124"}, "type": "Rectangle"}, {"id": "shape-304c41d1", "name": "\u53f3\u5f8c0.3 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "259", "OriginY": "255", "Rotation": "315", "Type": "Field", "Width": "634"}, "type": "Rectangle"}, {"id": "shape-ab5bbac7", "name": "\u53f3\u5f8c0.3 Speed down Rectangle", "rectangle": {"Height": "824", "OriginX": "294", "OriginY": "290", "Rotation": "315", "Type": "Field", "Width": "1072"}, "type": "Rectangle"}, {"id": "shape-642d2586", "name": "\u53f3\u5f8c0.3 Speed up Rectangle", "rectangle": {"Height": "1024", "OriginX": "361", "OriginY": "361", "Rotation": "315", "Type": "Field", "Width": "1575"}, "type": "Rectangle"}, {"id": "shape-3c5070bd", "name": "\u53f30.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-200", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "700"}, "type": "Rectangle"}, {"id": "shape-a7fdd216", "name": "\u53f30.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-200", "OriginY": "462", "Rotation": "0", "Type": "Field", "Width": "1300"}, "type": "Rectangle"}, {"id": "shape-d9f1df83", "name": "\u53f3\u524d0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-255", "OriginY": "259", "Rotation": "45", "Type": "Field", "Width": "585"}, "type": "Rectangle"}, {"id": "shape-ff6b0afc", "name": "\u53f3\u524d0.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-324", "OriginY": "324", "Rotation": "45", "Type": "Field", "Width": "1183"}, "type": "Rectangle"}, {"id": "shape-1f8f9857", "name": "\u524d0.15 Protective Rectangle", "rectangle": {"Height": "700", "OriginX": "-362", "OriginY": "500", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"id": "shape-fdc6b054", "name": "\u524d0.15 Speed up Rectangle", "rectangle": {"Height": "1300", "OriginX": "-462", "OriginY": "1100", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"id": "shape-f2b041f4", "name": "\u5de6\u524d0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-158", "OriginY": "668", "Rotation": "315", "Type": "Field", "Width": "585"}, "type": "Rectangle"}, {"id": "shape-e845f2ef", "name": "\u5de6\u524d0.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-509", "OriginY": "1167", "Rotation": "315", "Type": "Field", "Width": "1187"}, "type": "Rectangle"}, {"id": "shape-ef93506e", "name": "\u5de60.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-500", "OriginY": "362", "Rotation": "0", "Type": "Field", "Width": "700"}, "type": "Rectangle"}, {"id": "shape-33910a95", "name": "\u5de60.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-1100", "OriginY": "462", "Rotation": "0", "Type": "Field", "Width": "1300"}, "type": "Rectangle"}, {"id": "shape-f7585b29", "name": "\u5de6\u5f8c0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "-666", "OriginY": "-158", "Rotation": "45", "Type": "Field", "Width": "587"}, "type": "Rectangle"}, {"id": "shape-3b094552", "name": "\u5de6\u5f8c0.15 Speed up Rectangle", "rectangle": {"Height": "924", "OriginX": "-1159", "OriginY": "-503", "Rotation": "45", "Type": "Field", "Width": "1177"}, "type": "Rectangle"}, {"id": "shape-8762e3dd", "name": "\u5f8c0.15 Protective Rectangle", "rectangle": {"Height": "700", "OriginX": "-362", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "724"}, "type": "Rectangle"}, {"id": "shape-d1e78034", "name": "\u5f8c0.15 Speed up Rectangle", "rectangle": {"Height": "1300", "OriginX": "-462", "OriginY": "200", "Rotation": "0", "Type": "Field", "Width": "924"}, "type": "Rectangle"}, {"id": "shape-54a8e8e9", "name": "\u53f3\u5f8c0.15 Protective Rectangle", "rectangle": {"Height": "724", "OriginX": "257", "OriginY": "257", "Rotation": "315", "Type": "Field", "Width": "586"}, "type": "Rectangle"}, {"id": "shape-2837d67e", "name": "\u53f3\u5f8c0.15 Speed up Rectangle", "rectangle": {"Height": "1024", "OriginX": "362", "OriginY": "360", "Rotation": "315", "Type": "Field", "Width": "1180"}, "type": "Rectangle"}, {"circle": {"CenterX": "0", "CenterY": "0", "Radius": "542", "Type": "Field"}, "id": "shape-48390845", "name": "\u56de\u8ee2 Protective Circle", "type": "Circle"}, {"id": "shape-44a93288", "name": "Stop(minimum) Protective Polygon", "polygon": {"Type": "Field", "points": [{"X": "-245", "Y": "86"}, {"X": "-98", "Y": "-161"}, {"X": "98", "Y": "-163"}, {"X": "240", "Y": "79"}, {"X": "139", "Y": "250"}, {"X": "-137", "Y": "247"}]}, "type": "Polygon"}, {"id": "shape-9723422d", "name": "Stop(minimum) Protective Polygon", "polygon": {"Type": "CutOut", "points": [{"X": "-173", "Y": "160"}, {"X": "-1", "Y": "227"}, {"X": "165", "Y": "157"}, {"X": "0", "Y": "-242"}]}, "type": "Polygon"}, {"circle": {"CenterX": "-1", "CenterY": "-163", "Radius": "1", "Type": "Field"}, "id": "shape-5c45a7d5", "name": "Stop(minimum) Protective Circle", "type": "Circle"}, {"circle": {"CenterX": "0", "CenterY": "-167", "Radius": "99", "Type": "Field"}, "id": "shape-6be78c0c", "name": "Stop(minimum) Protective Circle", "type": "Circle"}, {"circle": {"CenterX": "-190", "CenterY": "166", "Radius": "99", "Type": "Field"}, "id": "shape-05b6c553", "name": "Stop(minimum) Protective Circle", "type": "Circle"}, {"circle": {"CenterX": "188", "CenterY": "164", "Radius": "99", "Type": "Field"}, "id": "shape-b27e3efe", "name": "Stop(minimum) Protective Circle", "type": "Circle"}];
        const shapeModal = document.getElementById("shape-modal");
        const shapeModalBody = document.getElementById("shape-modal-body");
        const shapeModalTitle = document.getElementById("shape-modal-title");
        const shapeModalSave = document.getElementById("shape-modal-save");
        const shapeModalCancel = document.getElementById("shape-modal-cancel");
        const shapeModalClose = document.getElementById("shape-modal-close");
        const shapeModalWindow = document.querySelector("#shape-modal .modal-window");
        const shapeModalHeader = shapeModalWindow?.querySelector(".modal-header");
        const saveTriOrbBtn = document.getElementById("btn-save-triorb");
        const saveLegacyBtn = document.getElementById("btn-save-legacy");
        const originTrace = findOriginTrace(defaultFigure);

        let currentFigure = cloneFigure(defaultFigure);
        let scanPlanes = initializeScanPlanes(initialScanPlanes);
        let triorbShapes = initializeTriOrbShapes(initialTriOrbShapes);
        let triorbSource = "" || "";
        let fieldsets = initializeFieldsets(initialFieldsets);
        let fieldsetDevices = initializeFieldsetDevices(initialFieldsetDevices);
        let fieldsetGlobalGeometry = initializeGlobalGeometry(initialFieldsetGlobal);
        let globalMultipleSampling = deriveInitialMultipleSampling(fieldsets);
        let legendVisible = true;
        let fieldOfViewDegrees = parseNumeric(fieldOfViewInput?.value, 270);
        const debugMode = Boolean(new URLSearchParams(window.location.search).get("debug"));
        if (debugMode) {
          document.body.classList.add("debug-mode");
        }
        let globalResolution = parseNumeric(globalResolutionInput?.value, 70);
        let globalTolerancePositive = parseNumeric(globalTolerancePositiveInput?.value, 0);
        let globalToleranceNegative = parseNumeric(globalToleranceNegativeInput?.value, 0);
        globalResolution = deriveFieldAttribute(fieldsets, "Resolution", globalResolution);
        globalTolerancePositive = deriveFieldAttribute(fieldsets, "TolerancePositive", globalTolerancePositive);
        globalToleranceNegative = deriveFieldAttribute(fieldsets, "ToleranceNegative", globalToleranceNegative);
        applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
        if (globalMultipleSamplingInput) {
          globalMultipleSamplingInput.value = globalMultipleSampling;
        }
        if (globalResolutionInput) {
          globalResolutionInput.value = globalResolution;
        }
        if (globalTolerancePositiveInput) {
          globalTolerancePositiveInput.value = globalTolerancePositive;
        }
        if (globalToleranceNegativeInput) {
          globalToleranceNegativeInput.value = globalToleranceNegative;
        }
          updateGlobalFieldAttributes();

          let lastHoverPoint = null;
        let modalShapeMeta = null;
        let modalOriginalShape = null;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let modalDragStartX = 0;
        let modalDragStartY = 0;
        let isModalDragging = false;

        renderScanPlanes();
        renderFieldsets();
        renderFieldsetDevices();
        renderFieldsetGlobal();
        renderFieldsetCheckboxes();
        renderTriOrbShapes();

        function initializeScanPlanes(data) {
          let planes;
          if (!Array.isArray(data) || !data.length) {
            planes = [createDefaultScanPlane(0)];
          } else {
            planes = data.map((plane, index) => ({
              attributes: { ...(plane.attributes || {}), Index: plane.attributes?.Index ?? String(index) },
              devices: Array.isArray(plane.devices)
                ? plane.devices.map((device, dIdx) => ({
                    attributes: { ...(device.attributes || {}), Index: device.attributes?.Index ?? String(dIdx) },
                  }))
                : [],
            }));
          }
          planes.forEach(ensureDefaultScanDevices);
          return planes;
        }

        function cloneFigure(figure) {
          return JSON.parse(JSON.stringify(figure));
        }

        function setStatus(message, state = "ok") {
          statusText.textContent = message;
          const resolvedState =
            typeof state === "string" ? state : state ? "error" : "ok";
          statusText.dataset.state = resolvedState;
        }

        function renderFigure() {
          syncPlotSize();
          const baseData = (currentFigure.data || []).map((trace, index) => {
            const copy = { ...trace };
            const originalName = copy.name || `Trace ${index + 1}`;
            copy.name = formatLegendLabel(originalName);
            return copy;
          });
          const triOrbShapeTraces = buildTriOrbShapeTraces();
          const overlayTraces = buildFieldsetTraces();
          const layout = {
            ...(currentFigure.layout || {}),
            showlegend: legendVisible,
            legend: {
              ...(currentFigure.layout?.legend || {}),
              x: 0,
              y: 1,
              xanchor: "left",
              yanchor: "top",
              orientation: "v",
              bgcolor: "rgba(255, 255, 255, 0.88)",
              borderwidth: 0,
              font: {
                ...(currentFigure.layout?.legend?.font || {}),
                size: 11,
                color: "#0f172a",
              },
            },
            xaxis: {
              ...(currentFigure.layout?.xaxis || {}),
              title: "",
            },
            yaxis: {
              ...(currentFigure.layout?.yaxis || {}),
              title: "",
            },
          };
          Plotly.react(
            plotNode,
            triOrbShapeTraces.concat(baseData).concat(overlayTraces),
            layout,
            figureConfig
          );
        }

        function buildFieldsetTraces() {
          if (!Array.isArray(fieldsets) || !fieldsets.length) {
            return [];
          }
          const traces = [];
          fieldsets.forEach((fieldset, fieldsetIndex) => {
            if (!fieldset || fieldset.visible === false) {
              return;
            }
            const fieldsetName =
              fieldset.attributes?.Name || `Fieldset ${fieldsetIndex + 1}`;
            (fieldset.fields || []).forEach((field, fieldIndex) => {
              const fieldName =
                field.attributes?.Name || `Field ${fieldIndex + 1}`;
              const labelPrefix = `${fieldsetName} / ${fieldName}`;
              const color = getFieldsetColor(fieldsetIndex + fieldIndex);
              const fieldType = field.attributes?.Fieldtype || "ProtectiveSafeBlanking";
              (field.shapeRefs || []).forEach((shapeRef, shapeRefIndex) => {
                const shapeIndex = triorbShapes.findIndex(
                  (item) => item.id === shapeRef.shapeId
                );
                if (shapeIndex < 0) {
                  return;
                }
                const shape = triorbShapes[shapeIndex];
                if (!shape) {
                  return;
                }
                const shapeLabel = `${labelPrefix} / ${shape.name || shape.type}`;
                let shapeTrace = null;
                switch (shape.type) {
                  case "Rectangle":
                    if (shape.rectangle) {
                      shapeTrace = buildRectangleTrace(
                        shape.rectangle,
                        color,
                        shapeLabel,
                        fieldType,
                        fieldsetIndex,
                        fieldIndex,
                        shapeRefIndex
                      );
                    }
                    break;
                  case "Circle":
                    if (shape.circle) {
                      shapeTrace = buildCircleTrace(
                        shape.circle,
                        color,
                        shapeLabel,
                        fieldType,
                        fieldsetIndex,
                        fieldIndex,
                        shapeRefIndex
                      );
                    }
                    break;
                  case "Polygon":
                  default:
                    if (shape.polygon) {
                      shapeTrace = buildPolygonTrace(
                        shape.polygon,
                        color,
                        shapeLabel,
                        fieldType,
                        fieldsetIndex,
                        fieldIndex,
                        shapeRefIndex
                      );
                    }
                    break;
                }
                if (shapeTrace) {
                  shapeTrace.name = formatLegendLabel(shapeLabel);
                  shapeTrace.meta = {
                    ...shapeTrace.meta,
                    isTriOrbShape: true,
                    shapeId: shape.id,
                    shapeIndex,
                    shapeType: shape.type,
                  };
                  traces.push(shapeTrace);
                }
              });
            });
          });
          const deviceTraces = buildDeviceOverlayTraces();
          return deviceTraces.concat(traces);
        }

function buildPolygonTrace(polygon, color, label, fieldType, fieldsetIndex, fieldIndex, polygonIndex) {
          const points = Array.isArray(polygon?.points) ? polygon.points : [];
          if (points.length < 2) {
            return null;
          }
          const coords = points.map((point) => ({
            x: parseNumeric(point.X, 0),
            y: parseNumeric(point.Y, 0),
          }));
          if (!coords.length) {
            return null;
          }
          const x = coords.map((point) => point.x);
          const y = coords.map((point) => point.y);
          const first = coords[0];
          const last = coords[coords.length - 1];
          if (first.x !== last.x || first.y !== last.y) {
            x.push(first.x);
            y.push(first.y);
          } else {
            x.push(first.x);
            y.push(first.y);
          }
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, polygon?.attributes?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.12),
            name: truncatedLabel,
            meta: {
              fullLabel: label,
              kind: "polygon",
              fieldsetIndex,
              fieldIndex,
              shapeIndex: polygonIndex,
              shapeType: polygon?.attributes?.Type || "CutOut",
            },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x,
            y,
          };
        }

function buildRectangleTrace(rectangle, color, label, fieldType, fieldsetIndex, fieldIndex, rectangleIndex) {
          const corners = getRectangleCornerPoints(rectangle);
          if (!corners || !corners.length) {
            return null;
          }
          const rotated = corners.concat(corners[0]);
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, rectangle?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.08),
            name: truncatedLabel,
            meta: {
              fullLabel: label,
              kind: "rectangle",
              fieldsetIndex,
              fieldIndex,
              shapeIndex: rectangleIndex,
              shapeType: rectangle?.Type || "Field",
            },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x: rotated.map((point) => point.x),
            y: rotated.map((point) => point.y),
          };
        }

function buildCircleTrace(circle, color, label, fieldType, fieldsetIndex, fieldIndex, circleIndex) {
          if (!circle) {
            return null;
          }
          const radius = parseNumeric(circle.Radius, NaN);
          if (!Number.isFinite(radius) || radius <= 0) {
            return null;
          }
          const centerX = parseNumeric(circle.CenterX, 0);
          const centerY = parseNumeric(circle.CenterY, 0);
          const x = [];
          const y = [];
          for (let i = 0; i <= circleSampleSegments; i += 1) {
            const angle = (i / circleSampleSegments) * Math.PI * 2;
            x.push(centerX + radius * Math.cos(angle));
            y.push(centerY + radius * Math.sin(angle));
          }
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, circle?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.08),
            name: truncatedLabel,
            meta: {
              fullLabel: label,
              kind: "circle",
              fieldsetIndex,
              fieldIndex,
              shapeIndex: circleIndex,
              shapeType: circle?.Type || "Field",
            },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x,
            y,
          };
        }

        function getRectangleCornerPoints(rectangle) {
          if (!rectangle) {
            return null;
          }
          const width = parseNumeric(rectangle.Width, NaN);
          const height = parseNumeric(rectangle.Height, NaN);
          if (!Number.isFinite(width) || !Number.isFinite(height) || width === 0 || height === 0) {
            return null;
          }
          const originX = parseNumeric(rectangle.OriginX, 0);
          const originY = parseNumeric(rectangle.OriginY, 0);
          const rotationDeg = parseNumeric(rectangle.Rotation, 0);
          const rotation = degreesToRadians(rotationDeg);
          const topLeft = { x: originX, y: originY };
          const topRight = { x: originX + width, y: originY };
          const bottomRight = { x: originX + width, y: originY - height };
          const bottomLeft = { x: originX, y: originY - height };
          const corners = [topLeft, topRight, bottomRight, bottomLeft];
          if (rotation === 0) {
            return corners;
          }
          return corners.map((corner) => rotateAroundCorner(corner, rotation, topLeft));
        }

        function rotatePoint(x, y, radians, originX, originY) {
          const cos = Math.cos(radians);
          const sin = Math.sin(radians);
          return {
            x: originX + x * cos - y * sin,
            y: originY + x * sin + y * cos,
          };
        }

        function rotateAroundCorner(point, radians, origin) {
          const translatedX = point.x - origin.x;
          const translatedY = point.y - origin.y;
          const rotated = rotatePoint(translatedX, translatedY, radians, 0, 0);
          return {
            x: rotated.x + origin.x,
            y: rotated.y + origin.y,
          };
        }

        function degreesToRadians(value) {
          return (Number(value) * Math.PI) / 180;
        }

        function normalizeDegrees(value) {
          const deg = Number(value);
          if (!Number.isFinite(deg)) {
            return 0;
          }
          const normalized = deg % 360;
          return normalized < 0 ? normalized + 360 : normalized;
        }

        function parseNumeric(value, fallback = NaN) {
          const num = Number.parseFloat(value);
          return Number.isFinite(num) ? num : fallback;
        }

        function withAlpha(color, alpha) {
          if (!color || typeof color !== "string") {
            return `rgba(15, 23, 42, ${alpha})`;
          }
          if (!color.startsWith("#")) {
            return color;
          }
          let hex = color.replace("#", "").trim();
          if (hex.length === 3) {
            hex = hex
              .split("")
              .map((ch) => ch + ch)
              .join("");
          }
          if (hex.length !== 6) {
            return color;
          }
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getFieldsetColor(index) {
          if (!Array.isArray(fieldsetColorPalette) || !fieldsetColorPalette.length) {
            return "#0f172a";
          }
          const safeIndex = Number.isFinite(index) && index >= 0 ? index : 0;
          return fieldsetColorPalette[safeIndex % fieldsetColorPalette.length];
        }

        function calculateVisibleFieldsetRadius() {
          let maxDistance = 0;
          fieldsets.forEach((fieldset) => {
            if (fieldset.visible === false) {
              return;
            }
            (fieldset.fields || []).forEach((field) => {
              (field.polygons || []).forEach((polygon) => {
                (polygon.points || []).forEach((point) => {
                  const x = parseNumeric(point.X, 0);
                  const y = parseNumeric(point.Y, 0);
                  const dist = Math.hypot(x, y);
                  if (dist > maxDistance) {
                    maxDistance = dist;
                  }
                });
              });
              (field.rectangles || []).forEach((rectangle) => {
                const corners = getRectangleCornerPoints(rectangle) || [];
                corners.forEach((corner) => {
                  const dist = Math.hypot(corner.x, corner.y);
                  if (dist > maxDistance) {
                    maxDistance = dist;
                  }
                });
              });
              (field.circles || []).forEach((circle) => {
                const centerX = parseNumeric(circle.CenterX, 0);
                const centerY = parseNumeric(circle.CenterY, 0);
                const radius = Math.max(0, parseNumeric(circle.Radius, 0));
                const dist = Math.hypot(centerX, centerY) + radius;
                if (dist > maxDistance) {
                  maxDistance = dist;
                }
              });
            });
          });
          return maxDistance;
        }

        function calculateDeviceFanRadius() {
          const visibleRadius = calculateVisibleFieldsetRadius();
          if (!Number.isFinite(visibleRadius) || visibleRadius <= 0) {
            return 1000;
          }
          return visibleRadius + 500;
        }

        function buildDeviceOverlayTraces() {
          if (!Array.isArray(fieldsetDevices) || !fieldsetDevices.length) {
            return [];
          }
          const radius = calculateDeviceFanRadius();
          const traces = [];
          fieldsetDevices.forEach((device, deviceIndex) => {
            const attrs = device?.attributes || {};
            const x = parseNumeric(attrs.PositionX, NaN);
            const y = parseNumeric(attrs.PositionY, NaN);
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
              return;
            }
            const deviceLabel =
              attrs.Typekey ||
              attrs.DeviceName ||
              `Device ${deviceIndex + 1}`;
            traces.push({
              type: "scatter",
              mode: "markers",
              marker: { color: "#111", size: 8 },
              name: formatLegendLabel(`${deviceLabel} position`),
              meta: { fullLabel: deviceLabel },
              hovertemplate:
                "<b>%{meta.fullLabel}</b><br>X: %{x}<br>Y: %{y}<extra></extra>",
              x: [x],
              y: [y],
              showlegend: false,
            });
            const rotation = parseNumeric(attrs.Rotation, 0);
            if (
              Number.isFinite(radius) &&
              radius > 0 &&
              Number.isFinite(fieldOfViewDegrees) &&
              fieldOfViewDegrees > 0
            ) {
              const fanTrace = buildDeviceFanTrace(
                x,
                y,
                rotation,
                radius,
                fieldOfViewDegrees,
                deviceLabel
              );
              if (fanTrace) {
                traces.push(fanTrace);
              }
            }
          });
          return traces;
        }

        function buildTriOrbShapeTraces() {
          if (!Array.isArray(triorbShapes) || !triorbShapes.length) {
            return [];
          }
          return triorbShapes
            .map((shape, shapeIndex) => {
              if (shape.visible === false) {
                return null;
              }
              const color = getFieldsetColor(shapeIndex + 2);
              const label = `${shape.name || `Shape ${shapeIndex + 1}`} (${shape.type})`;
              const fieldType = shape.type === "Warning" ? "WarningSafeBlanking" : "ProtectiveSafeBlanking";
              switch (shape.type) {
                case "Rectangle":
                  if (!shape.rectangle) return null;
                  return buildRectangleTrace(
                    shape.rectangle,
                    color,
                    label,
                    fieldType,
                    0,
                    0,
                    shapeIndex
                  );
                case "Circle":
                  if (!shape.circle) return null;
                  return buildCircleTrace(
                    shape.circle,
                    color,
                    label,
                    fieldType,
                    0,
                    0,
                    shapeIndex
                  );
                case "Polygon":
                default:
                  if (!shape.polygon) return null;
                  return buildPolygonTrace(
                    shape.polygon,
                    color,
                    label,
                    fieldType,
                    0,
                    0,
                    shapeIndex
                  );
              }
            })
            .filter(Boolean);
        }

        function buildDeviceFanTrace(originX, originY, rotationDeg, radius, fovDeg, label) {
          if (
            !Number.isFinite(radius) ||
            radius <= 0 ||
            !Number.isFinite(fovDeg) ||
            fovDeg <= 0
          ) {
            return null;
          }
          const adjustedRotation = normalizeDegrees(rotationDeg + 90);
          const halfFov = fovDeg / 2;
          const start = degreesToRadians(adjustedRotation - halfFov);
          const end = degreesToRadians(adjustedRotation + halfFov);
          const steps = Math.max(6, Math.floor(fovDeg / 6));
          const points = [];
          points.push({ x: originX, y: originY });
          points.push({
            x: originX + radius * Math.cos(start),
            y: originY + radius * Math.sin(start),
          });
          for (let i = 1; i <= steps; i += 1) {
            const angle = start + ((end - start) * i) / steps;
            points.push({
              x: originX + radius * Math.cos(angle),
              y: originY + radius * Math.sin(angle),
            });
          }
          points.push({
            x: originX,
            y: originY,
          });
          return {
            type: "scatter",
            mode: "lines",
            line: { color: "#111", width: 1.2, dash: "dot" },
            fill: "toself",
            fillcolor: "rgba(17, 17, 17, 0.08)",
            name: formatLegendLabel(`${label} FOV`),
            meta: { fullLabel: `${label} Field of View` },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x: points.map((point) => point.x),
            y: points.map((point) => point.y),
            showlegend: false,
          };
        }

        function resolveShapeStyle(fieldType, shapeType) {
          const normalizedField = String(fieldType || "").toLowerCase();
          const normalizedShape = String(shapeType || "").toLowerCase();
          const isProtective = normalizedField.includes("protective");
          const isWarning = normalizedField.includes("warning");
          const protectiveOrWarning = isProtective || isWarning;

          const style = {
            lineWidth: 1.5,
            lineDash: "solid",
          };

          if (normalizedShape === "field") {
            if (isWarning) {
              style.lineWidth = 1;
              style.lineDash = "solid";
            } else if (isProtective) {
              style.lineWidth = 2;
              style.lineDash = "solid";
            }
          } else if (normalizedShape === "cutout" && protectiveOrWarning) {
            style.lineWidth = 2;
            style.lineDash = "dash";
          }

          return style;
        }

        function formatLegendLabel(label) {
          const text = String(label ?? "").trim();
          if (!text) {
            return "Trace";
          }
          if (text.length <= legendLabelMaxLength) {
            return text;
          }
          return `${text.slice(0, legendLabelMaxLength - 3)}...`;
        }

        function resetFigure() {
          currentFigure = cloneFigure(defaultFigure);
          renderFigure();
          setStatus("Default plot restored.");
        }

        function createDefaultScanPlane(index = scanPlanes.length) {
          return {
            attributes: {
              Index: String(index),
              Name: `Monitoring plane ${index + 1}`,
              ScanPlaneDirection: "Horizontal",
              UseReferenceContour: "false",
              ObjectSize: "70",
              MultipleSampling: "2",
              MultipleSamplingOff2OnActivated: "false",
              SelectedCaseSwitching: "Fast",
            },
            devices: createDefaultScanPlaneDevices(),
          };
        }

        function createDefaultDevice(index = 0, overrides = {}) {
          return {
            attributes: {
              Index: String(index),
              DeviceName: overrides.DeviceName || `Device ${index + 1}`,
              Typekey: overrides.Typekey || "NANS3-CAAZ30ZA1P02",
              TypekeyVersion: overrides.TypekeyVersion || "1.0",
              TypekeyDisplayVersion: overrides.TypekeyDisplayVersion || "V 1.0.0",
              ResponseTime: overrides.ResponseTime || "30",
              ScanResolutionAddition: overrides.ScanResolutionAddition || "0",
            },
          };
        }

        function createDefaultScanPlaneDevices() {
          if (!defaultScanDeviceTemplates.length) {
            return [createDefaultDevice(0)];
          }
          return defaultScanDeviceTemplates.map((template, index) =>
            createDefaultDevice(index, template)
          );
        }

        function renderScanPlanes() {
          if (!scanPlanesContainer) return;
          scanPlanesContainer.innerHTML = scanPlanes
            .map((plane, planeIndex) => {
              const planeFields = Object.entries(plane.attributes || {})
                .map(
                  ([key, value]) => `
              <div class="scanplane-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="scanplane-attr"
                  data-plane-index="${planeIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`
                )
                .join("");

              const deviceCards = (plane.devices || [])
                .map((device, deviceIndex) => {
                  const deviceFields = Object.entries(device.attributes || {})
                    .map(
                      ([key, value]) => `
                  <div class="device-field">
                    <label>${escapeHtml(key)}</label>
                    <input
                      type="text"
                      class="device-attr"
                      data-plane-index="${planeIndex}"
                      data-device-index="${deviceIndex}"
                      data-field="${escapeHtml(key)}"
                      value="${escapeHtml(value ?? "")}"
                    />
                  </div>`
                    )
                    .join("");

                  return `
                <div class="device-card" data-plane-index="${planeIndex}" data-device-index="${deviceIndex}">
                  <details class="device-details" open>
                    <summary>
                      <span>Device #${deviceIndex + 1}</span>
                      <span class="device-summary">${device.attributes.DeviceName || ""}</span>
                      <button
                        type="button"
                        class="inline-btn inline-danger"
                        data-action="remove-device"
                        data-plane-index="${planeIndex}"
                        data-device-index="${deviceIndex}"
                      >
                        Remove
                      </button>
                    </summary>
                    <div class="device-fields">${deviceFields}</div>
                  </details>
                </div>`;
                })
                .join("");

              return `
            <div class="scanplane-card" data-plane-index="${planeIndex}">
              <details class="scanplane-details" open>
                <summary>
                  <span>ScanPlane #${planeIndex + 1}</span>
                  <span class="scanplane-summary">${plane.attributes.Name || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-scanplane"
                    data-plane-index="${planeIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="scanplane-fields">${planeFields}</div>
                <div class="scanplane-devices">
                  ${deviceCards || "<p>No devices yet.</p>"}
                  <div class="scanplane-actions">
                    <button
                      type="button"
                      class="inline-btn add-device-btn"
                      data-action="add-device"
                      data-plane-index="${planeIndex}"
                    >
                      + Device
                    </button>
                  </div>
                </div>
              </details>
            </div>`;
            })
            .join("");
        }

        function ensureDefaultScanDevices(plane) {
          if (!plane) {
            return;
          }
          plane.devices = Array.isArray(plane.devices) ? plane.devices : [];
          const existingNames = new Set(
            plane.devices
              .map((device) => (device.attributes?.DeviceName || "").toLowerCase())
              .filter(Boolean)
          );
          defaultScanDeviceTemplates.forEach((template) => {
            const templateName = (template.DeviceName || "").toLowerCase();
            if (templateName && !existingNames.has(templateName)) {
              const newDevice = createDefaultDevice(plane.devices.length, template);
              plane.devices.push(newDevice);
              existingNames.add(templateName);
            }
          });
        }

        function updateScanPlaneAttribute(planeIndex, field, value) {
          if (scanPlanes[planeIndex]) {
            scanPlanes[planeIndex].attributes[field] = value;
            if (field === "Name") {
              const summary = document.querySelector(
                `.scanplane-card[data-plane-index="${planeIndex}"] .scanplane-summary`
              );
              if (summary) {
                summary.textContent = value;
              }
            }
          }
        }

        function updateDeviceAttribute(planeIndex, deviceIndex, field, value) {
          const plane = scanPlanes[planeIndex];
          if (plane && plane.devices && plane.devices[deviceIndex]) {
            plane.devices[deviceIndex].attributes[field] = value;
            if (field === "DeviceName") {
              const deviceSummary = document.querySelector(
                `.device-card[data-plane-index="${planeIndex}"][data-device-index="${deviceIndex}"] .device-summary`
              );
              if (deviceSummary) {
                deviceSummary.textContent = value;
              }
            }
          }
        }

        function getScanPlaneDeviceOptions() {
          const options = [];
          const seen = new Set();
          scanPlanes.forEach((plane) => {
            (plane.devices || []).forEach((device) => {
              const attrs = device.attributes || {};
              const typekey = attrs.Typekey;
              if (!typekey) {
                return;
              }
              if (seen.has(typekey)) {
                return;
              }
              seen.add(typekey);
              options.push({
                typekey,
                typekeyDisplayVersion: attrs.TypekeyDisplayVersion || "",
                typekeyVersion: attrs.TypekeyVersion || "",
                label: attrs.DeviceName
                  ? `${attrs.DeviceName} (${typekey})`
                  : typekey,
              });
            });
          });
          return options;
        }

        function findScanPlaneDeviceByTypekey(typekey) {
          if (!typekey) {
            return null;
          }
          for (const plane of scanPlanes) {
            for (const device of plane.devices || []) {
              if ((device.attributes || {}).Typekey === typekey) {
                return device;
              }
            }
          }
          return null;
        }

        function applyScanPlaneDeviceAttributes(targetDevice, typekey) {
          targetDevice.attributes = targetDevice.attributes || {};
          targetDevice.attributes.Typekey = typekey || "";

          const source = findScanPlaneDeviceByTypekey(typekey);
          const keys = ["TypekeyDisplayVersion", "TypekeyVersion"];
          keys.forEach((key) => {
            targetDevice.attributes[key] =
              (source?.attributes || {})[key] || "";
          });
        }

        function findTriOrbShapeById(shapeId) {
          return triorbShapes.find((shape) => shape.id === shapeId) || null;
        }

        function normalizeFieldShapeRefs(field) {
          if (!field) {
            return [];
          }
          if (Array.isArray(field.shapeRefs) && field.shapeRefs.length) {
            return field.shapeRefs
              .map((ref) => (ref && ref.shapeId ? { shapeId: ref.shapeId } : null))
              .filter(Boolean);
          }
          return [];
        }

        function initializeFieldsets(data) {
          if (!Array.isArray(data) || !data.length) {
            return [createDefaultFieldset(0)];
          }
          return data.map((fieldset, index) => ({
            attributes: {
              Name: fieldset.attributes?.Name || `Fieldset ${index + 1}`,
              ...fieldset.attributes,
            },
            fields:
              Array.isArray(fieldset.fields) && fieldset.fields.length
                ? fieldset.fields.map((field, fieldIndex) => ({
                    attributes: {
                      Name: field.attributes?.Name || `Field ${fieldIndex + 1}`,
                      ...field.attributes,
                    },
                    shapeRefs: normalizeFieldShapeRefs(field),
                  }))
                : [createDefaultField(0)],
            visible: fieldset.visible !== false,
          }));
        }

        function createDefaultFieldset(index = fieldsets.length) {
          const isFirst = index === 0;
          return {
            attributes: {
              Name: isFirst ? "Default" : `Fieldset ${index + 1}`,
              NameLatin9Key: `FS_DEFAULT_${index + 1}`,
            },
            fields: [createDefaultField(0)],
            visible: true,
          };
        }

        function createDefaultField(index = 0) {
          const samplingValue =
            typeof globalMultipleSampling === "undefined"
              ? "2"
              : globalMultipleSampling;
          const newShape = createDefaultTriOrbShape(triorbShapes.length, "Polygon");
          triorbShapes.push(newShape);
          return {
            attributes: {
              Name: `Field ${index + 1}`,
              Fieldtype: "ProtectiveSafeBlanking",
              MultipleSampling: samplingValue,
              Resolution: "70",
              TolerancePositive: "0",
              ToleranceNegative: "0",
            },
            shapeRefs: [{ shapeId: newShape.id }],
          };
        }

        function deriveInitialMultipleSampling(fieldsetList) {
          for (const fieldset of fieldsetList) {
            if (!fieldset.fields) continue;
            for (const field of fieldset.fields) {
              if (field.attributes?.MultipleSampling) {
                return field.attributes.MultipleSampling;
              }
            }
          }
          return "2";
        }

        function deriveFieldAttribute(fieldsetList, key, fallback) {
          for (const fieldset of fieldsetList) {
            if (!fieldset.fields) continue;
            for (const field of fieldset.fields) {
              if (field.attributes && key in field.attributes) {
                return parseNumeric(field.attributes[key], fallback);
              }
            }
          }
          return fallback;
        }

        function applyGlobalMultipleSampling(value, { rerender = true } = {}) {
          globalMultipleSampling = value;
          if (globalMultipleSamplingInput) {
            globalMultipleSamplingInput.value = value;
          }
          updateGlobalFieldAttributes();
          if (rerender) {
            renderFieldsets();
          }
        }

        function createDefaultPolygon() {
          return {
            attributes: { Type: "CutOut" },
            points: [
              { X: "0", Y: "0" },
              { X: "100", Y: "0" },
              { X: "100", Y: "100" },
              { X: "0", Y: "100" },
            ],
          };
        }

        function createDefaultRectangle() {
          return {
            Type: "Field",
            OriginX: "0",
            OriginY: "0",
            Height: "100",
            Width: "100",
            Rotation: "0",
          };
        }

        function createDefaultCircle() {
          return {
            Type: "Field",
            CenterX: "0",
            CenterY: "0",
            Radius: "100",
          };
        }

        function formatFieldsetAttribute(fieldsetIndex, key, value) {
          return `
              <div class="fieldset-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="fieldset-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
        }

        function formatFieldAttribute(fieldsetIndex, fieldIndex, key, value) {
          const hidden =
            ["MultipleSampling", "Resolution", "TolerancePositive", "ToleranceNegative"].includes(
              key
            ) && !debugMode;
          if (hidden) return "";
          const hiddenClass = hidden ? "field-attribute debug-hidden" : "field-attribute";
          if (key === "Fieldtype") {
            const options = ["ProtectiveSafeBlanking", "WarningSafeBlanking"]
              .map(
                (opt) =>
                  `<option value="${opt}"${opt === value ? " selected" : ""}>${opt}</option>`
              )
              .join("");
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <select
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                >
                  ${options}
                </select>
              </div>`;
          }
          if (key === "MultipleSampling") {
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input type="number" value="${escapeHtml(globalMultipleSampling)}" min="2" max="16" readonly />
              </div>`;
          }
          if (key === "Resolution") {
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input type="number" value="${escapeHtml(String(globalResolution))}" readonly />
              </div>`;
          }
          if (key === "TolerancePositive" || key === "ToleranceNegative") {
            const bound = key === "TolerancePositive" ? globalTolerancePositive : globalToleranceNegative;
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input type="number" value="${escapeHtml(String(bound))}" readonly />
              </div>`;
          }
          return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
        }

        function renderFieldsets() {
          if (!fieldsetsContainer) {
            return;
          }
          const detailState = captureFieldsetDetailState();
          if (!fieldsets.length) {
            fieldsetsContainer.innerHTML = "<p>No fieldsets defined.</p>";
            return;
          }
          fieldsetsContainer.innerHTML = fieldsets
            .map((fieldset, fieldsetIndex) => {
              const fieldsetFields = Object.entries(fieldset.attributes || {})
                .map(([key, value]) => formatFieldsetAttribute(fieldsetIndex, key, value))
                .join("");

              const fieldCards = (fieldset.fields || [])
                .map((field, fieldIndex) => {
                  const fieldAttrs = Object.entries(field.attributes || {})
                    .map(([key, value]) => {
                      if (key === "Fieldtype") {
                        const options = [
                          "ProtectiveSafeBlanking",
                          "WarningSafeBlanking",
                        ]
                          .map(
                            (opt) =>
                              `<option value="${opt}"${
                                opt === value ? " selected" : ""
                              }>${opt}</option>`
                          )
                          .join("");
                        return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <select
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                >
                  ${options}
                </select>
              </div>`;
                      }
                      if (key === "MultipleSampling") {
                        return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <input
                  type="number"
                  value="${escapeHtml(globalMultipleSampling)}"
                  min="2"
                  max="16"
                  readonly
                />
              </div>`;
                      }
                      return formatFieldAttribute(fieldsetIndex, fieldIndex, key, value);
                    })
                    .join("");

                  const shapeRefs = Array.isArray(field.shapeRefs) ? field.shapeRefs : [];
                  const shapeItems =
                    shapeRefs
                      .map((shapeRef, shapeIndex) => {
                        const shape = findTriOrbShapeById(shapeRef.shapeId);
                        if (!shape) {
                          return `
                            <div class="field-shape-entry missing">
                              <span>Shape removed</span>
                            </div>`;
                        }
                        return `
                          <div
                            class="field-shape-entry"
                            data-shape-index="${shapeIndex}"
                          >
                            <div class="shape-info">
                              <span class="shape-name">${escapeHtml(
                                shape.name || shape.id
                              )}</span>
                              <span class="shape-type">${escapeHtml(shape.type)}</span>
                            </div>
                            <div class="shape-actions">
                              <button
                                type="button"
                                class="inline-btn shape-mini-btn"
                                data-action="edit-field-shape"
                                data-shape-id="${escapeHtml(shape.id)}"
                              >
                                Edit
                              </button>
                              <button
                                type="button"
                                class="inline-btn inline-danger shape-mini-btn"
                                data-action="remove-field-shape"
                                data-fieldset-index="${fieldsetIndex}"
                                data-field-index="${fieldIndex}"
                                data-shape-index="${shapeIndex}"
                              >
                                Remove
                              </button>
                            </div>
                          </div>`;
                      })
                      .join("") || "<p>No shapes assigned.</p>";
                  const shapeControls = renderFieldShapeControls(
                    fieldsetIndex,
                    fieldIndex,
                    field
                  );

                  return `
            <div
              class="field-card"
              data-fieldset-index="${fieldsetIndex}"
              data-field-index="${fieldIndex}"
            >
              <details class="field-details" open>
                <summary>
                  <span>Field #${fieldIndex + 1}</span>
                  <span class="field-summary">${field.attributes.Name || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-field"
                    data-fieldset-index="${fieldsetIndex}"
                    data-field-index="${fieldIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="field-attributes">${fieldAttrs}</div>
                <div class="shape-section">
                  <h4>Assigned Shapes</h4>
                  <div class="shape-list">${shapeItems}</div>
                  ${shapeControls}
                </div>
              </details>
            </div>`;
                })
                .join("") || "<p>No fields defined.</p>";

              return `
          <div class="fieldset-card" data-fieldset-index="${fieldsetIndex}">
            <details class="fieldset-details">
              <summary>
                <span>Fieldset #${fieldsetIndex + 1}</span>
                <span class="fieldset-summary">${fieldset.attributes.Name || ""}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger"
                  data-action="remove-fieldset"
                  data-fieldset-index="${fieldsetIndex}"
                >
                  Remove
                </button>
              </summary>
              <div class="fieldset-fields">${fieldsetFields}</div>
              <div class="field-card-list">
                ${fieldCards}
                <div class="field-actions">
                  <button
                    type="button"
                    class="inline-btn"
                    data-action="add-field"
                    data-fieldset-index="${fieldsetIndex}"
                  >
                    + Field
                  </button>
                </div>
              </div>
            </details>
          </div>`;
            })
            .join("");
          renderFieldsetCheckboxes();
          renderFigure();
          restoreFieldsetDetailState(detailState);
        }

        function renderFieldShapeControls(fieldsetIndex, fieldIndex, field) {
          const currentIds = new Set((field.shapeRefs || []).map((ref) => ref.shapeId));
          const availableShapes = triorbShapes.filter((shape) => !currentIds.has(shape.id));
          if (!availableShapes.length) {
            return `<p class="shape-controls-note">No additional shapes to add.</p>`;
          }
          const options = availableShapes
            .map(
              (shape) =>
                `<option value="${escapeHtml(shape.id)}">${escapeHtml(
                  shape.name || shape.id
                )} (${escapeHtml(shape.type)})</option>`
            )
            .join("");
          return `
            <div class="shape-controls">
              <select
                class="field-shape-selector"
                data-fieldset-index="${fieldsetIndex}"
                data-field-index="${fieldIndex}"
              >
                ${options}
              </select>
              <button
                type="button"
                class="inline-btn"
                data-action="add-field-shape"
                data-fieldset-index="${fieldsetIndex}"
                data-field-index="${fieldIndex}"
              >
                Add Shape
              </button>
            </div>`;
        }

        function initializeTriOrbShapes(data) {
          if (!Array.isArray(data) || !data.length) {
            return [createDefaultTriOrbShape(0)];
          }
          return data.map((shape, index) => ({
            id: shape.id || createShapeId(),
            name: shape.name || `Shape ${index + 1}`,
            type: shape.type || "Polygon",
            polygon: shape.polygon || createDefaultPolygonDetails(),
            rectangle: shape.rectangle || createDefaultRectangleDetails(),
            circle: shape.circle || createDefaultCircleDetails(),
            visible: shape.visible !== false,
          }));
        }

        function createDefaultTriOrbShape(index, kind = "Polygon") {
          const shape = {
            id: createShapeId(),
            name: `Shape ${index + 1}`,
            type: kind,
            polygon: createDefaultPolygonDetails(),
            rectangle: createDefaultRectangleDetails(),
            circle: createDefaultCircleDetails(),
            visible: true,
          };
          return shape;
        }

        function createShapeId() {
          return `shape-${Math.random().toString(36).slice(2, 10)}`;
        }

        function createDefaultPolygonDetails() {
          return {
            Type: "CutOut",
            points: [
              { X: "0", Y: "0" },
              { X: "100", Y: "0" },
              { X: "100", Y: "100" },
              { X: "0", Y: "100" },
            ],
          };
        }

        function formatPolygonPoints(points) {
          return (points || [])
            .map((point) => `(${point.X},${point.Y})`)
            .join(",");
        }

        function parsePolygonPoints(value) {
          const sanitized = (value || "").trim();
          if (!sanitized) {
            return [];
          }
          return sanitized
            .split("),")
            .map((segment) => segment.replace(/[()]/g, "").trim())
            .filter(Boolean)
            .map((pair) => {
              const [x, y] = pair.split(",").map((v) => v.trim());
              return { X: x || "0", Y: y || "0" };
            });
        }

        function createDefaultRectangleDetails() {
          return {
            Type: "Field",
            OriginX: "0",
            OriginY: "0",
            Width: "100",
            Height: "100",
            Rotation: "0",
          };
        }

        function createDefaultCircleDetails() {
          return {
            Type: "Field",
            CenterX: "0",
            CenterY: "0",
            Radius: "100",
          };
        }

        function renderTriOrbShapes() {
          if (!triorbShapesContainer) {
            return;
          }
          if (!triorbShapes.length) {
            triorbShapesContainer.innerHTML = "<p>No shapes defined.</p>";
            return;
          }
          triorbShapesContainer.innerHTML = triorbShapes
            .map((shape, shapeIndex) => renderTriOrbShapeCard(shapeIndex, shape))
            .join("");
        }

        function renderTriOrbShapeCard(shapeIndex, shape) {
          const details = renderTriOrbShapeDetails(shape, shapeIndex);
          const typeSelect = ["Polygon", "Rectangle", "Circle"]
            .map(
              (type) =>
                `<option value="${type}"${
                  type === shape.type ? " selected" : ""
                }>${type}</option>`
            )
            .join("");
          return `
            <div class="triorb-shape-card" data-shape-index="${shapeIndex}">
          <div class="shape-row">
            <span>ID: ${escapeHtml(shape.id)}</span>
            <label>
              Name
              <input
                type="text"
                class="triorb-shape-name"
                data-shape-index="${shapeIndex}"
                data-field="name"
                value="${escapeHtml(shape.name)}"
              />
            </label>
            <label>
              Type
              <select
                class="triorb-shape-type"
                data-shape-index="${shapeIndex}"
                data-field="type"
              >
                ${typeSelect}
              </select>
            </label>
            <button
              type="button"
              class="inline-btn inline-danger shape-mini-btn"
              data-action="remove-triorb-shape"
              data-shape-index="${shapeIndex}"
            >
              Remove
            </button>
          </div>
              <div class="shape-details">${details}</div>
            </div>`;
        }

        function renderTriOrbShapeDetails(shape, shapeIndex) {
          switch (shape.type) {
            case "Rectangle":
              return ["OriginX", "OriginY", "Width", "Height", "Rotation"]
                .map((key) => {
                  const value = shape.rectangle?.[key] ?? "0";
                  return `
                    <label>
                      ${key}
                      <input
                        type="number"
                        data-shape-index="${shapeIndex}"
                        data-field="${key}"
                        data-shape-dimension="rectangle"
                        value="${escapeHtml(value)}"
                      />
                    </label>`;
                })
                .join("");
            case "Circle":
              return ["CenterX", "CenterY", "Radius"]
                .map((key) => {
                  const value = shape.circle?.[key] ?? "0";
                  return `
                    <label>
                      ${key}
                      <input
                        type="number"
                        data-shape-index="${shapeIndex}"
                        data-field="${key}"
                        data-shape-dimension="circle"
                        value="${escapeHtml(value)}"
                      />
                    </label>`;
                })
                .join("");
            case "Polygon":
            default:
              return `
                <label>
                  Points (format: (x1,y1),(x2,y2),...)
                  <input
                    type="text"
                    data-shape-index="${shapeIndex}"
                    data-shape-dimension="polygon"
                    value="${escapeHtml(formatPolygonPoints(shape.polygon?.points || []))}"
                  />
                </label>`;
          }
        }

        function handleTriOrbShapeInput(event) {
          const target = event.target;
          if (!target) return;
          const shapeIndex = Number(target.dataset.shapeIndex);
          if (!Number.isFinite(shapeIndex)) {
            return;
          }
          const shape = triorbShapes[shapeIndex];
          if (!shape) return;
          const field = target.dataset.field;
          const dimension = target.dataset["shapeDimension"];
          let changed = false;
          if (field === "name") {
            shape.name = target.value;
            changed = true;
          } else if (field === "type") {
            shape.type = target.value;
            if (shape.type === "Polygon") {
              shape.polygon = shape.polygon || createDefaultPolygonDetails();
            } else if (shape.type === "Rectangle") {
              shape.rectangle = shape.rectangle || createDefaultRectangleDetails();
            } else if (shape.type === "Circle") {
              shape.circle = shape.circle || createDefaultCircleDetails();
            }
            renderTriOrbShapes();
            renderTriOrbShapeCheckboxes();
            changed = true;
          } else if (dimension === "polygon") {
            if (!shape.polygon) {
              shape.polygon = createDefaultPolygonDetails();
            }
            shape.polygon.points = parsePolygonPoints(target.value);
            changed = true;
          } else if (dimension === "rectangle") {
            shape.rectangle = shape.rectangle || createDefaultRectangleDetails();
            shape.rectangle[field] = target.value;
            changed = true;
          } else if (dimension === "circle") {
            shape.circle = shape.circle || createDefaultCircleDetails();
            shape.circle[field] = target.value;
            changed = true;
          }
          if (changed) {
            renderFigure();
            renderFieldsets();
          }
        }

        function renderPolygonEditor(fieldsetIndex, fieldIndex, polygon, polygonIndex) {
          const typeSelect = renderShapeTypeSelect(
            "polygon",
            polygon.attributes?.Type || "CutOut",
            "polygon-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "polygon-index": polygonIndex,
            }
          );
          const pointInputs = (polygon.points || [])
            .map(
              (point, pointIndex) => `
              <div class="shape-point" data-point-index="${pointIndex}">
                <label>X</label>
                <input
                  type="number"
                  class="polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                  data-axis="X"
                  value="${escapeHtml(point.X ?? "0")}"
                />
                <label>Y</label>
                <input
                  type="number"
                  class="polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                  data-axis="Y"
                  value="${escapeHtml(point.Y ?? "0")}"
                />
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                >
                  Remove
                </button>
              </div>`
            )
            .join("");
          return `
            <div class="shape-entry" data-shape="polygon">
              <div class="shape-title">
                <span>Polygon #${polygonIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-polygon"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-points">
                ${pointInputs || "<p>No points.</p>"}
              </div>
              <div class="shape-actions">
                <button
                  type="button"
                  class="inline-btn shape-mini-btn"
                  data-action="add-polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                >
                  Add Point
                </button>
              </div>
            </div>`;
        }

        function renderRectangleEditor(fieldsetIndex, fieldIndex, rectangle, rectangleIndex) {
          const typeSelect = renderShapeTypeSelect(
            "rectangle",
            rectangle.Type || "Field",
            "rectangle-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "rectangle-index": rectangleIndex,
            }
          );
          const fields = ["OriginX", "OriginY", "Width", "Height", "Rotation"].map(
            (key) => `
              <div class="shape-field">
                <label>${key}</label>
                <input
                  type="number"
                  class="rectangle-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-rectangle-index="${rectangleIndex}"
                  data-field="${key}"
                  value="${escapeHtml(rectangle[key] ?? "0")}"
                />
              </div>`
          );
          return `
            <div class="shape-entry" data-shape="rectangle">
              <div class="shape-title">
                <span>Rectangle #${rectangleIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-rectangle"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-rectangle-index="${rectangleIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-grid">
                ${fields.join("")}
              </div>
            </div>`;
        }

        function renderCircleEditor(fieldsetIndex, fieldIndex, circle, circleIndex) {
          const typeSelect = renderShapeTypeSelect(
            "circle",
            circle.Type || "Field",
            "circle-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "circle-index": circleIndex,
            }
          );
          const circleFields = ["CenterX", "CenterY", "Radius"].map(
            (key) => `
              <div class="shape-field">
                <label>${key}</label>
                <input
                  type="number"
                  class="circle-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-circle-index="${circleIndex}"
                  data-field="${key}"
                  value="${escapeHtml(circle[key] ?? "0")}"
                />
              </div>`
          );
          return `
            <div class="shape-entry" data-shape="circle">
              <div class="shape-title">
                <span>Circle #${circleIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-circle"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-circle-index="${circleIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-grid">
                ${circleFields.join("")}
              </div>
            </div>`;
        }

        function renderShapeTypeSelect(kind, currentValue, className, dataAttrs) {
          const options = new Set(shapeTypeOptions[kind] || []);
          if (currentValue) {
            options.add(currentValue);
          }
          const dataAttrString = Object.entries(dataAttrs || {})
            .map(([key, value]) => ` data-${key}="${escapeHtml(String(value))}"`)
            .join("");
          return `
            <select class="${className}"${dataAttrString}>
              ${Array.from(options)
                .map(
                  (option) =>
                    `<option value="${escapeHtml(option)}"${
                      option === currentValue ? " selected" : ""
                    }>${escapeHtml(option)}</option>`
                )
                .join("")}
            </select>`;
        }

        function updateFieldAttribute(fieldsetIndex, fieldIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          if (!field) return;
          field.attributes[key] = value;
          if (key === "Name") {
            const summary = document.querySelector(
              `.field-card[data-fieldset-index="${fieldsetIndex}"][data-field-index="${fieldIndex}"] .field-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFigure();
        }

        function updatePolygonAttribute(fieldsetIndex, fieldIndex, polygonIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon) return;
          polygon.attributes = polygon.attributes || {};
          polygon.attributes[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function updatePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex, axis, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon || !polygon.points || !polygon.points[pointIndex]) {
            return;
          }
          polygon.points[pointIndex][axis] = value;
          renderFieldsets();
          renderFigure();
        }

        function updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const rectangle = field?.rectangles?.[rectangleIndex];
          if (!rectangle) return;
          rectangle[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const circle = field?.circles?.[circleIndex];
          if (!circle) return;
          circle[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function captureFieldsetDetailState() {
          if (!fieldsetsContainer) {
            return { fieldsets: new Set(), fields: new Set() };
          }
          const state = { fieldsets: new Set(), fields: new Set() };
          fieldsetsContainer.querySelectorAll(".fieldset-card").forEach((card) => {
            const fieldsetIndex = card.dataset.fieldsetIndex;
            const details = card.querySelector("details");
            if (details?.open && fieldsetIndex !== undefined) {
              state.fieldsets.add(fieldsetIndex);
            }
            card.querySelectorAll(".field-card").forEach((fieldCard) => {
              const fieldIndex = fieldCard.dataset.fieldIndex;
              const fieldDetails = fieldCard.querySelector("details");
              if (
                fieldDetails?.open &&
                fieldsetIndex !== undefined &&
                fieldIndex !== undefined
              ) {
                state.fields.add(`${fieldsetIndex}:${fieldIndex}`);
              }
            });
          });
          return state;
        }

        function restoreFieldsetDetailState(state) {
          if (!state || !fieldsetsContainer) {
            return;
          }
          fieldsetsContainer.querySelectorAll(".fieldset-card").forEach((card) => {
            const fieldsetIndex = card.dataset.fieldsetIndex;
            if (state.fieldsets.has(fieldsetIndex)) {
              const details = card.querySelector("details");
              if (details) {
                details.open = true;
              }
            }
            card.querySelectorAll(".field-card").forEach((fieldCard) => {
              const fieldIndex = fieldCard.dataset.fieldIndex;
              const key = `${fieldsetIndex}:${fieldIndex}`;
              if (state.fields.has(key)) {
                const details = fieldCard.querySelector("details");
                if (details) {
                  details.open = true;
                }
              }
            });
          });
        }

        function getFieldEntry(fieldsetIndex, fieldIndex) {
          const fieldset = fieldsets[fieldsetIndex];
          if (!fieldset || !fieldset.fields) {
            return null;
          }
          return fieldset.fields[fieldIndex] || null;
        }

        function addPolygon(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.polygons = field.polygons || [];
          field.polygons.push(createDefaultPolygon());
          renderFieldsets();
        }

        function removePolygon(fieldsetIndex, fieldIndex, polygonIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.polygons) return;
          field.polygons.splice(polygonIndex, 1);
          renderFieldsets();
        }

        function addPolygonPoint(fieldsetIndex, fieldIndex, polygonIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon) return;
          polygon.points = polygon.points || [];
          polygon.points.push({ X: "0", Y: "0" });
          renderFieldsets();
        }

        function removePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon || !polygon.points) return;
          polygon.points.splice(pointIndex, 1);
          renderFieldsets();
        }

        function addCircle(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.circles = field.circles || [];
          field.circles.push(createDefaultCircle());
          renderFieldsets();
        }

        function removeCircle(fieldsetIndex, fieldIndex, circleIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.circles) return;
          field.circles.splice(circleIndex, 1);
          renderFieldsets();
        }

        function addRectangle(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.rectangles = field.rectangles || [];
          field.rectangles.push(createDefaultRectangle());
          renderFieldsets();
        }

        function removeRectangle(fieldsetIndex, fieldIndex, rectangleIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.rectangles) return;
          field.rectangles.splice(rectangleIndex, 1);
          renderFieldsets();
        }

        function resolveShape(meta) {
          if (!meta) return null;
          if (meta.isTriOrbShape) {
            return triorbShapes[meta.shapeIndex] || null;
          }
          const field = getFieldEntry(meta.fieldsetIndex, meta.fieldIndex);
          if (!field) {
            return null;
          }
          switch (meta.kind) {
            case "polygon":
              return field.polygons?.[meta.shapeIndex] || null;
            case "rectangle":
              return field.rectangles?.[meta.shapeIndex] || null;
            case "circle":
              return field.circles?.[meta.shapeIndex] || null;
            default:
              return null;
          }
        }

        function cloneShape(shape) {
          if (!shape) return null;
          return JSON.parse(JSON.stringify(shape));
        }

        function restoreShapeValues(target, source) {
          if (!target || !source) return;
          Object.keys(target).forEach((key) => {
            delete target[key];
          });
          Object.keys(source).forEach((key) => {
            target[key] = source[key];
          });
        }

        function renderShapeModal(meta) {
          const shape = resolveShape(meta);
          if (!shape) return;
          modalShapeMeta = meta;
          modalOriginalShape = cloneShape(shape);
          shapeModalTitle.textContent = `${meta.shapeType || meta.kind} Edit`;
          let html = "";
          if (meta.kind === "polygon") {
            const points = shape.points || [];
            html += points
              .map(
                (point, idx) => `
              <div class="modal-field">
                <label>Point ${idx + 1} X(mm)</label>
                <input type="number" data-point-index="${idx}" data-axis="X" value="${escapeHtml(
                  point.X ?? "0"
                )}" />
                <label>Point ${idx + 1} Y(mm)</label>
                <input type="number" data-point-index="${idx}" data-axis="Y" value="${escapeHtml(
                  point.Y ?? "0"
                )}" />
              </div>`
              )
              .join("");
          } else if (meta.kind === "rectangle") {
            ["OriginX", "OriginY", "Width", "Height", "Rotation"].forEach((key) => {
              html += `
              <div class="modal-field">
                <label>${key}(mm)</label>
                <input type="number" data-field="${key}" value="${escapeHtml(shape[key] ?? "0")}" />
              </div>`;
            });
          } else if (meta.kind === "circle") {
            ["CenterX", "CenterY", "Radius"].forEach((key) => {
              html += `
              <div class="modal-field">
                <label>${key}(mm)</label>
                <input type="number" data-field="${key}" value="${escapeHtml(shape[key] ?? "0")}" />
              </div>`;
            });
          }
          shapeModalBody.innerHTML = html;
          shapeModal.classList.add("active");
          shapeModal.setAttribute("aria-hidden", "false");
          ensureModalPosition();
        }

        function handleShapeModalInput(event) {
          if (!modalShapeMeta) {
            return;
          }
          const shape = resolveShape(modalShapeMeta);
          if (!shape) {
            return;
          }
          const input = event.target;
          if (!input) {
            return;
          }
          if (modalShapeMeta.kind === "polygon") {
            const pointIndex = Number(input.dataset.pointIndex);
            const axis = input.dataset.axis;
            if (Number.isFinite(pointIndex) && axis) {
              shape.points = shape.points || [];
              if (!shape.points[pointIndex]) {
                shape.points[pointIndex] = { X: "0", Y: "0" };
              }
              shape.points[pointIndex][axis] = input.value;
            }
          } else {
            const field = input.dataset.field;
            if (field) {
              shape[field] = input.value;
            }
          }
          renderFieldsets();
          renderFigure();
        }

        function closeShapeModal() {
          modalShapeMeta = null;
          modalOriginalShape = null;
          shapeModal.classList.remove("active");
          shapeModal.setAttribute("aria-hidden", "true");
        }

        function saveShapeModal() {
          if (!modalShapeMeta) {
            return;
          }
          const shape = resolveShape(modalShapeMeta);
          modalOriginalShape = cloneShape(shape);
          closeShapeModal();
        }

        function cancelShapeModal() {
          if (modalShapeMeta && modalOriginalShape) {
            const shape = resolveShape(modalShapeMeta);
            if (shape) {
              restoreShapeValues(shape, modalOriginalShape);
            }
          }
          renderFieldsets();
          renderFigure();
          closeShapeModal();
        }

        function ensureModalPosition() {
          if (shapeModalWindow) {
            shapeModalWindow.style.transform = `translate(${modalOffsetX}px, ${modalOffsetY}px)`;
          }
        }

        function startModalDrag(event) {
          if (!shapeModalWindow) return;
          isModalDragging = true;
          modalDragStartX = event.clientX;
          modalDragStartY = event.clientY;
          shapeModalWindow.style.transition = "none";
        }

        function updateModalDrag(event) {
          if (!isModalDragging) return;
          const dx = event.clientX - modalDragStartX;
          const dy = event.clientY - modalDragStartY;
          if (shapeModalWindow) {
            shapeModalWindow.style.transform = `translate(${modalOffsetX + dx}px, ${modalOffsetY + dy}px)`;
          }
        }

        function endModalDrag(event) {
          if (!isModalDragging) return;
          const dx = event.clientX - modalDragStartX;
          const dy = event.clientY - modalDragStartY;
          modalOffsetX += dx;
          modalOffsetY += dy;
          isModalDragging = false;
          if (shapeModalWindow) {
            shapeModalWindow.style.transition = "";
            ensureModalPosition();
          }
        }

        function formatAttributeBadges(attrs) {
          if (!attrs) {
            return "";
          }
          return Object.entries(attrs)
            .map(
              ([key, value]) =>
                `<span>${escapeHtml(key)}=${escapeHtml(value ?? "")}</span>`
            )
            .join("");
        }

        function initializeFieldsetDevices(data) {
          let devices;
          if (!Array.isArray(data) || !data.length) {
            devices = getDefaultFieldsetDevices();
          } else {
            devices = data.map((device, index) => ({
              attributes: {
                DeviceName: device.attributes?.DeviceName || `Device ${index + 1}`,
                ...device.attributes,
              },
            }));
          }
          ensureDefaultFieldsetDevices(devices);
          return devices;
        }

        function initializeGlobalGeometry(data) {
          if (!data || typeof data !== "object" || !Object.keys(data).length) {
            return { UseGlobalGeometry: "false" };
          }
          return { ...data };
        }

        function createDefaultFieldsetDevice(index = 0, overrides = {}) {
          const options = getScanPlaneDeviceOptions();
          const fallbackOption = options[Math.min(index, Math.max(0, options.length - 1))] || options[0];
          const defaultTypekey = fallbackOption?.typekey || "NANS3-CAAZ30ZA1P02";
          const device = {
            attributes: {
              Typekey: defaultTypekey,
              TypekeyVersion: fallbackOption?.typekeyVersion || "1.0",
              TypekeyDisplayVersion: fallbackOption?.typekeyDisplayVersion || "V 1.0.0",
              PositionX: "0",
              PositionY: "0",
              Rotation: "0",
              StandingUpsideDown: "false",
              ...overrides,
            },
          };
          if (defaultTypekey) {
            applyScanPlaneDeviceAttributes(device, defaultTypekey);
          }
          return device;
        }

        function getDefaultFieldsetDevices() {
          if (!defaultFieldsetDeviceTemplates.length) {
            return [createDefaultFieldsetDevice(0)];
          }
          return defaultFieldsetDeviceTemplates.map((template, index) =>
            createDefaultFieldsetDevice(index, template)
          );
        }

        function ensureDefaultFieldsetDevices(devices) {
          if (!Array.isArray(devices)) {
            return;
          }
          defaultFieldsetDeviceTemplates.forEach((template) => {
            const exists = devices.some(
              (device) =>
                device.attributes?.PositionX === template.PositionX &&
                device.attributes?.PositionY === template.PositionY &&
                device.attributes?.Rotation === template.Rotation
            );
            if (!exists) {
              devices.push(createDefaultFieldsetDevice(devices.length, template));
            }
          });
        }

        function renderFieldsetDevices() {
          if (!fieldsetDevicesContainer) return;
          if (!fieldsetDevices.length) {
            fieldsetDevicesContainer.innerHTML = "<p>No devices defined.</p>";
            return;
          }
          const deviceOptions = getScanPlaneDeviceOptions();
          fieldsetDevicesContainer.innerHTML = fieldsetDevices
            .map((device, deviceIndex) => {
              const sanitizedAttributes = Object.entries(device.attributes || {}).filter(
                ([key]) => key !== "DeviceName"
              );
              const deviceFields = sanitizedAttributes
                .map(([key, value]) => {
                  if (key === "Typekey") {
                    const optionsHtml =
                      '<option value="">-- Select Typekey --</option>' +
                      (deviceOptions.length
                        ? deviceOptions
                            .map(
                              (opt) =>
                                `<option value="${escapeHtml(opt.typekey)}"${
                                  opt.typekey === value ? " selected" : ""
                                }>${escapeHtml(opt.label)}</option>`
                            )
                            .join("")
                        : `<option value="${escapeHtml(value || "")}" selected>${escapeHtml(
                            value || ""
                          )}</option>`);
                    return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <select
                  class="fieldset-device-typekey"
                  data-device-index="${deviceIndex}"
                >
                  ${optionsHtml}
                </select>
              </div>`;
                  }
                  if (["TypekeyDisplayVersion", "TypekeyVersion"].includes(key)) {
                    return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input type="text" value="${escapeHtml(value ?? "")}" readonly />
              </div>`;
                  }
                  return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="fieldset-device-attr"
                  data-device-index="${deviceIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
                })
                .join("");

              return `
            <div class="device-card" data-fieldset-device-index="${deviceIndex}">
              <details class="device-details" open>
                <summary>
                  <span>Device #${deviceIndex + 1}</span>
                  <span class="device-summary">${device.attributes.Typekey || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-fieldset-device"
                    data-device-index="${deviceIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="device-fields">${deviceFields}</div>
              </details>
            </div>`;
            })
            .join("");
        }

        function renderFieldsetGlobal() {
          if (!fieldsetGlobalContainer) return;
          const entries =
            Object.entries(fieldsetGlobalGeometry || {}).length > 0
              ? Object.entries(fieldsetGlobalGeometry)
              : [["UseGlobalGeometry", "false"]];
          fieldsetGlobalContainer.innerHTML = entries
            .map(
              ([key, value]) => `
          <div class="fieldset-field">
            <label>${escapeHtml(key)}</label>
            <input
              type="text"
              class="fieldset-global-attr"
              data-field="${escapeHtml(key)}"
              value="${escapeHtml(value ?? "")}"
            />
          </div>`
            )
            .join("");
        }

        function updateFieldsetDeviceAttribute(deviceIndex, key, value) {
          const device = fieldsetDevices[deviceIndex];
          if (!device) return;
          device.attributes[key] = value;
          if (key === "Typekey") {
            const summary = document.querySelector(
              `.device-card[data-fieldset-device-index="${deviceIndex}"] .device-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFigure();
        }

        function updateGlobalGeometryAttribute(key, value) {
          fieldsetGlobalGeometry[key] = value;
        }

        function buildBaseSdImportExportLines() {
          const figure = currentFigure || defaultFigure;
          const fileInfoLines = buildFileInfoLines();
          const scanPlaneLines = buildScanPlanesXml();
          const fieldsetLines = buildFieldsetsXml();
          const rootAttrOverrides = {
            ...rootAttributes,
            Timestamp: new Date().toISOString(),
            "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          };
          const rootAttrText = buildRootAttributes(
            rootAttrOverrides,
            getAttributeOrder("SdImportExport")
          );
          const lines = [
            '<?xml version="1.0" encoding="utf-8"?>',
            rootAttrText ? `<SdImportExport ${rootAttrText}>` : "<SdImportExport>",
            "  <FileInfo>",
            ...fileInfoLines,
            "  </FileInfo>",
            "  <Export_ScanPlanes>",
            ...scanPlaneLines,
            "  </Export_ScanPlanes>",
            "  <Export_FieldsetsAndFields>",
            ...fieldsetLines,
            "  </Export_FieldsetsAndFields>",
            "  <Export_CasetablesAndCases />",
            "</SdImportExport>",
          ];
          return lines;
        }

        function buildLegacyXml() {
          const lines = buildBaseSdImportExportLines();
          return lines.join("\n");
        }

        function buildTriOrbXml() {
          const lines = buildBaseSdImportExportLines().slice();
          lines.push("");
          if (!triorbSource) {
            triorbSource = "TriOrbAware";
          }
          const sourceAttr = triorbSource
            ? ` Source="${escapeXml(triorbSource)}"`
            : "";
          lines.push(`<TriOrb_SICK_SLS_Editor${sourceAttr}>`);
          lines.push("  <PlotlyData>");
          lines.push("    <Traces>");

          const figure = currentFigure || defaultFigure;
          (figure.data || []).forEach((trace, index) => {
            const name = escapeXml(trace?.name ?? `Trace ${index + 1}`);
            const mode = escapeXml(trace?.mode ?? "lines");
            lines.push(`      <Trace Name="${name}" Mode="${mode}">`);
            const len = Math.min(trace.x?.length || 0, trace.y?.length || 0);
            for (let i = 0; i < len; i += 1) {
              lines.push(`        <Point X="${trace.x[i]}" Y="${trace.y[i]}" />`);
            }
            lines.push("      </Trace>");
          });

          lines.push("    </Traces>");
          lines.push("  </PlotlyData>");
          lines.push("  <TriOrbMenu>");
          lines.push(
            `    <Device FieldOfView="${escapeXml(String(fieldOfViewDegrees || "270"))}" />`
          );
          lines.push(
            `    <Field MultipleSampling="${escapeXml(
              String(globalMultipleSampling || "2")
            )}">`
          );
          lines.push("      <CommonCutOut Name=\"CommonCutOut #1\">");
          lines.push("        <Polygon Name=\"Polygon #1\" />");
          lines.push("        <Circle Name=\"Circle #1\" />");
          lines.push("        <Rectangle Name=\"Rectangle #1\" />");
          lines.push("      </CommonCutOut>");
          lines.push("    </Field>");
          const shapeLines = buildTriOrbShapesXml();
          shapeLines.forEach((line) => lines.push(line));
          lines.push("  </TriOrbMenu>");
          lines.push("</TriOrb_SICK_SLS_Editor>");
          return lines.join("\n");
        }

        function buildScanPlanesXml() {
          if (!scanPlanes.length) {
            return ["    <!-- ScanPlane not set -->"];
          }
          const lines = [];
          scanPlanes.forEach((plane) => {
            const attrText = buildAttributeString(
              plane.attributes,
              getAttributeOrder("ScanPlane")
            );
            lines.push(`    <ScanPlane${attrText ? " " + attrText : ""}>`);
            if (plane.devices && plane.devices.length) {
              lines.push("      <Devices>");
              plane.devices.forEach((device) => {
                const deviceAttrs = buildAttributeString(
                  device.attributes,
                  getAttributeOrder("Device")
                );
                lines.push(`        <Device${deviceAttrs ? " " + deviceAttrs : ""} />`);
              });
              lines.push("      </Devices>");
            } else {
              lines.push("      <Devices />");
            }
            lines.push("    </ScanPlane>");
          });
          return lines;
        }

        function buildFieldsetsXml() {
          const lines = [];
          lines.push('    <ScanPlane Index="0">');

          lines.push("      <Devices>");
          if (fieldsetDevices.length) {
            fieldsetDevices.forEach((device) => {
              const sanitizedDeviceAttrs = { ...(device.attributes || {}) };
              delete sanitizedDeviceAttrs.DeviceName;
              const deviceAttrs = buildAttributeString(
                sanitizedDeviceAttrs,
                getAttributeOrder("Device")
              );
              lines.push(`        <Device${deviceAttrs ? " " + deviceAttrs : ""} />`);
            });
          } else {
            lines.push("        <!-- No devices -->");
          }
          lines.push("      </Devices>");

          const globalAttr = buildAttributeString(
            fieldsetGlobalGeometry,
            getAttributeOrder("GlobalGeometry")
          );
          lines.push(
            globalAttr
              ? `      <GlobalGeometry ${globalAttr} />`
              : "      <GlobalGeometry />"
          );

          lines.push("      <Fieldsets>");
          if (fieldsets.length) {
            fieldsets.forEach((fieldset) => {
            const attrText = buildAttributeString(
              fieldset.attributes,
              getAttributeOrder("Fieldset")
            );
            lines.push(`        <Fieldset${attrText ? " " + attrText : ""}>`);
            if (fieldset.fields && fieldset.fields.length) {
              fieldset.fields.forEach((field) => {
                const fieldAttrs = buildAttributeString(
                  field.attributes,
                  getAttributeOrder("Field")
                );
                lines.push(`          <Field${fieldAttrs ? " " + fieldAttrs : ""}>`);
                if (field.polygons && field.polygons.length) {
                  field.polygons.forEach((polygon) => {
                    const polygonAttrs = buildAttributeString(
                      polygon.attributes,
                      getAttributeOrder("Polygon")
                    );
                    lines.push(`            <Polygon${polygonAttrs ? " " + polygonAttrs : ""}>`);
                    if (polygon.points && polygon.points.length) {
                      polygon.points.forEach((point) => {
                        const pointAttrs = buildAttributeString(
                          point,
                          getAttributeOrder("Point")
                        );
                        lines.push(`              <Point${pointAttrs ? " " + pointAttrs : ""} />`);
                      });
                    }
                    lines.push("            </Polygon>");
                  });
                }
                if (field.circles && field.circles.length) {
                  field.circles.forEach((circle) => {
                    const circleAttrs = buildAttributeString(
                      circle,
                      getAttributeOrder("Circle")
                    );
                    lines.push(`            <Circle${circleAttrs ? " " + circleAttrs : ""} />`);
                  });
                }
                if (field.rectangles && field.rectangles.length) {
                  field.rectangles.forEach((rectangle) => {
                    const rectAttrs = buildAttributeString(
                      rectangle,
                      getAttributeOrder("Rectangle")
                    );
                    lines.push(`            <Rectangle${rectAttrs ? " " + rectAttrs : ""} />`);
                  });
                  }
                  lines.push("          </Field>");
                });
              } else {
                lines.push("          <!-- No fields -->");
              }
              lines.push("        </Fieldset>");
            });
          } else {
            lines.push("        <!-- No fieldsets -->");
          }
          lines.push("      </Fieldsets>");
          lines.push("    </ScanPlane>");
          return lines;
        }

        function buildAttributeString(attrs, order = []) {
          if (!attrs) return "";
          const keys = Object.keys(attrs);
          const orderedKeys = [];
          const remaining = new Set(keys);
          order.forEach((key) => {
            if (remaining.has(key)) {
              orderedKeys.push(key);
              remaining.delete(key);
            }
          });
          Array.from(remaining)
            .sort()
            .forEach((key) => orderedKeys.push(key));
          return orderedKeys
            .map(
              (key) =>
                `${sanitizeTagName(key)}="${escapeXml(String(attrs[key] ?? ""))}"`
            )
            .join(" ");
        }

        function getAttributeOrder(tag) {
          switch (tag) {
            case "SdImportExport":
              return ["Timestamp", "xmlns:xsd", "xmlns:xsi"];
            case "ScanPlane":
              return [
                "Index",
                "Name",
                "ScanPlaneDirection",
                "UseReferenceContour",
                "ObjectSize",
                "MultipleSampling",
                "MultipleSamplingOff2OnActivated",
                "SelectedCaseSwitching",
              ];
            case "Device":
              return [
                "Index",
                "Typekey",
                "TypekeyVersion",
                "TypekeyDisplayVersion",
                "DeviceName",
                "ResponseTime",
                "ScanResolutionAddition",
                "PositionX",
                "PositionY",
                "Rotation",
                "StandingUpsideDown",
              ];
            case "Fieldset":
              return ["Name", "NameLatin9Key"];
            case "Field":
              return [
                "Name",
                "Fieldtype",
                "MultipleSampling",
                "Resolution",
                "TolerancePositive",
                "ToleranceNegative",
              ];
            case "Polygon":
              return ["Type"];
            case "Rectangle":
              return ["Type", "OriginX", "OriginY", "Height", "Width", "Rotation"];
            case "Circle":
              return ["Type", "CenterX", "CenterY", "Radius"];
            case "Point":
              return ["X", "Y"];
            case "GlobalGeometry":
              return ["UseGlobalGeometry"];
            default:
              return [];
          }
        }

        function buildTriOrbShapesXml() {
          if (!Array.isArray(triorbShapes) || !triorbShapes.length) {
            return ["    <!-- No TriOrb shapes -->"];
          }
          const lines = [];
          lines.push("    <Shapes>");
          triorbShapes.forEach((shape) => {
            const shapeAttrs = buildAttributeString(
              { ID: shape.id, Name: shape.name, Type: shape.type },
              ["ID", "Name", "Type"]
            );
            lines.push(`      <Shape${shapeAttrs ? " " + shapeAttrs : ""}>`);
            if (shape.type === "Polygon" && shape.polygon) {
              const polygonAttr = buildAttributeString(
                { Type: shape.polygon.Type },
                ["Type"]
              );
              lines.push(`        <Polygon${polygonAttr ? " " + polygonAttr : ""}>`);
              (shape.polygon.points || []).forEach((point) => {
                const pointAttrs = buildAttributeString(point, getAttributeOrder("Point"));
                lines.push(`          <Point${pointAttrs ? " " + pointAttrs : ""} />`);
              });
              lines.push("        </Polygon>");
            } else if (shape.type === "Rectangle" && shape.rectangle) {
              const rectAttrs = buildAttributeString(
                shape.rectangle,
                getAttributeOrder("Rectangle")
              );
              lines.push(`        <Rectangle${rectAttrs ? " " + rectAttrs : ""} />`);
            } else if (shape.type === "Circle" && shape.circle) {
              const circleAttrs = buildAttributeString(shape.circle, getAttributeOrder("Circle"));
              lines.push(`        <Circle${circleAttrs ? " " + circleAttrs : ""} />`);
            }
            lines.push("      </Shape>");
          });
          lines.push("    </Shapes>");
          return lines;
        }

        function downloadXml(xmlString) {
          const blob = new Blob([xmlString], { type: "application/xml" });
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = `plot_${Date.now()}.sgexml`;
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          URL.revokeObjectURL(url);
        }

        function escapeXml(value) {
          return String(value ?? "").replace(/[<>&'\"]/g, (char) => {
            switch (char) {
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case "&":
                return "&amp;";
              case "'":
                return "&apos;";
              case "\"":
                return "&quot;";
              default:
                return char;
            }
          });
        }

        function escapeHtml(value) {
          return String(value ?? "").replace(/[&<>"']/g, (char) => {
            switch (char) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              case "'":
                return "&#39;";
              default:
                return char;
            }
          });
        }

        function sanitizeTagName(name) {
          return (name || "Field").replace(/[^\w:.-]/g, "_");
        }

        function buildFileInfoLines() {
          const scope = document.querySelector('[data-scope="fileinfo"]');
          if (!scope) {
            return ["    <!-- FileInfo not set -->"];
          }
          const inputs = Array.from(
            scope.querySelectorAll(
              ".menu-fileinfo-field input, .menu-fileinfo-field textarea"
            )
          );
          if (!inputs.length) {
            return ["    <!-- FileInfo not set -->"];
          }
          return inputs.map((input) => {
            const tag = sanitizeTagName(input.dataset.field || input.id || "Field");
            const rawValue = (input.value || "").trim();
            if (!rawValue) {
              return `    <${tag} />`;
            }
            const value = escapeXml(rawValue);
            return `    <${tag}>${value}</${tag}>`;
          });
        }

        function buildRootAttributes(attrs) {
          if (!attrs || typeof attrs !== "object") {
            return "";
          }
          return Object.entries(attrs)
            .map(
              ([key, value]) =>
                `${sanitizeTagName(key)}="${escapeXml(String(value ?? ""))}"`
            )
            .join(" ");
        }

        function buildRootAttributes(attrs, order = []) {
          if (!attrs || typeof attrs !== "object") {
            return "";
          }
          return buildAttributeString(attrs, order);
        }

        function parseXmlToFigure(xmlText) {
          const parser = new DOMParser();
          let doc = parser.parseFromString(xmlText, "application/xml");
          if (doc.querySelector("parsererror")) {
            const sanitized = xmlText.replace(/<\?xml[^>]*\?>/gi, "").trim();
            const wrapped = `<TriOrbWrapper>${sanitized}</TriOrbWrapper>`;
            doc = parser.parseFromString(wrapped, "application/xml");
          }
          if (doc.querySelector("parsererror")) {
            throw new Error("Failed to parse XML.");
          }

          populateFileInfoFromDoc(doc);
          populateScanPlanesFromDoc(doc);
          populateFieldsetsFromDoc(doc);

          const tracesFromPlotData = parsePlotDataTraces(doc);
          if (tracesFromPlotData.length) {
            return { traces: tracesFromPlotData, warning: "" };
          }

          const polygonTrace = parsePolygonTrace(doc);
          if (polygonTrace.length) {
            return { traces: polygonTrace, warning: "" };
          }

          return {
            traces: [],
            warning: "Plot data was not found; displaying an empty plot.",
          };
        }
        function parsePlotDataTraces(doc) {
          const traces = Array.from(
            doc.querySelectorAll(
              "PlotData > Trace, PlotlyData > Trace, PlotlyData > Traces > Trace, TriOrb_SICK_SLS_Editor > PlotlyData > Traces > Trace"
            )
          );
          return traces.map((traceNode, index) => {
            const points = Array.from(traceNode.getElementsByTagName("Point"));
            const x = [];
            const y = [];
            points.forEach((pt) => {
              const xVal = Number(pt.getAttribute("X"));
              const yVal = Number(pt.getAttribute("Y"));
              if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
                x.push(xVal);
                y.push(yVal);
              }
            });

            return buildTraceFromPoints(
              x,
              y,
              {
                name: traceNode.getAttribute("Name") || `Trace ${index + 1}`,
                mode: traceNode.getAttribute("Mode") || "lines+markers",
              },
              index
            );
          });
        }

        function parsePolygonTrace(doc) {
          const polygon = doc.querySelector("Polygon");
          if (!polygon) {
            return [];
          }

          const points = Array.from(polygon.getElementsByTagName("Point"));
          const x = [];
          const y = [];
          points.forEach((pt) => {
            const xVal = Number(pt.getAttribute("X"));
            const yVal = Number(pt.getAttribute("Y"));
            if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
              x.push(xVal);
              y.push(yVal);
            }
          });

          const polygonTrace = buildTraceFromPoints(
            x,
            y,
            {
              name: polygon.getAttribute("Type") || "Polygon",
              mode: "lines+markers",
              fill: "toself",
            },
            0
          );

          const traces = [polygonTrace];
          if (originTrace) {
            traces.push(cloneTrace(originTrace));
          }
          return traces;
        }
        function populateFileInfoFromDoc(doc) {
          const fileInfoNode = doc.querySelector("FileInfo");
          if (!fileInfoNode) return;
          const inputs = document.querySelectorAll(".menu-fileinfo-field input");
          inputs.forEach((input) => {
            const targetTag = input.dataset.field || sanitizeTagName(input.id || "Field");
            const element = fileInfoNode.getElementsByTagName(targetTag)[0];
            if (element && typeof element.textContent === "string") {
              input.value = element.textContent.trim();
            }
          });
        }

        function populateScanPlanesFromDoc(doc) {
          const planeNodes = doc.querySelectorAll("Export_ScanPlanes > ScanPlane");
          if (!planeNodes.length) {
            return;
          }
          scanPlanes = Array.from(planeNodes).map((planeNode, planeIndex) => {
            const attributes = {};
            Array.from(planeNode.attributes).forEach((attr) => {
              attributes[attr.name] = attr.value;
            });
            if (!("Index" in attributes)) {
              attributes.Index = String(planeIndex);
            }
            const devices = Array.from(planeNode.querySelectorAll("Devices > Device")).map((deviceNode, deviceIndex) => {
              const deviceAttrs = {};
              Array.from(deviceNode.attributes).forEach((attr) => {
                deviceAttrs[attr.name] = attr.value;
              });
              if (!("Index" in deviceAttrs)) {
                deviceAttrs.Index = String(deviceIndex);
              }
              return { attributes: deviceAttrs };
            });
            return { attributes, devices };
          });
          renderScanPlanes();
        }

        function populateFieldsetsFromDoc(doc) {
          const scanPlaneNode = doc.querySelector(
            "Export_FieldsetsAndFields > ScanPlane"
          );
          if (!scanPlaneNode) {
            fieldsets = [createDefaultFieldset(0)];
            fieldsetDevices = [createDefaultFieldsetDevice(0)];
            fieldsetGlobalGeometry = initializeGlobalGeometry({});
            renderFieldsets();
            renderFieldsetDevices();
            renderFieldsetGlobal();
            return;
          }

          const devicesParent = scanPlaneNode.querySelector("Devices");
          if (devicesParent) {
            fieldsetDevices = Array.from(
              devicesParent.querySelectorAll("Device")
            ).map((deviceNode, deviceIndex) => {
              const attrs = {};
              Array.from(deviceNode.attributes).forEach((attr) => {
                attrs[attr.name] = attr.value;
              });
              if (!("DeviceName" in attrs)) {
                attrs.DeviceName = `Device ${deviceIndex + 1}`;
              }
              return { attributes: attrs };
            });
          } else {
            fieldsetDevices = [];
          }

          const globalNode = scanPlaneNode.querySelector("GlobalGeometry");
          fieldsetGlobalGeometry = globalNode
            ? Array.from(globalNode.attributes).reduce((acc, attr) => {
                acc[attr.name] = attr.value;
                return acc;
              }, {})
            : { UseGlobalGeometry: "false" };

          const fieldsetsParent = scanPlaneNode.querySelector("Fieldsets");
          const fieldsetNodes = fieldsetsParent
            ? fieldsetsParent.querySelectorAll("Fieldset")
            : [];

          if (!fieldsetNodes.length) {
            fieldsets = [createDefaultFieldset(0)];
          } else {
          fieldsets = Array.from(fieldsetNodes).map((fieldsetNode, fieldsetIndex) => {
            const attributes = {};
            Array.from(fieldsetNode.attributes).forEach((attr) => {
              attributes[attr.name] = attr.value;
            });
              if (!("Name" in attributes)) {
                attributes.Name = `Fieldset ${fieldsetIndex + 1}`;
              }

              const fieldNodes = Array.from(
                fieldsetNode.querySelectorAll("Field")
              );

              const fields = fieldNodes.map((fieldNode, fieldIndex) => {
                const fieldAttrs = {};
                Array.from(fieldNode.attributes).forEach((attr) => {
                  fieldAttrs[attr.name] = attr.value;
                });
                if (!("Name" in fieldAttrs)) {
                  fieldAttrs.Name = `Field ${fieldIndex + 1}`;
                }

                const polygonNodes = Array.from(
                  fieldNode.querySelectorAll("Polygon")
                );
                const polygons = polygonNodes.map((polygonNode) => {
                  const polygonAttrs = {};
                  Array.from(polygonNode.attributes).forEach((attr) => {
                    polygonAttrs[attr.name] = attr.value;
                  });
                  const pointNodes = Array.from(polygonNode.querySelectorAll("Point"));
                  const points = pointNodes.map((pointNode) => {
                    const pointAttrs = {};
                    Array.from(pointNode.attributes).forEach((attr) => {
                      pointAttrs[attr.name] = attr.value;
                    });
                    return pointAttrs;
                  });
                  return { attributes: polygonAttrs, points };
                });

              const circleNodes = Array.from(
                fieldNode.querySelectorAll("Circle")
              );
              const circles = circleNodes.map((circleNode) => {
                const circleAttrs = {};
                Array.from(circleNode.attributes).forEach((attr) => {
                  circleAttrs[attr.name] = attr.value;
                });
                return circleAttrs;
              });

              const rectangleNodes = Array.from(
                fieldNode.querySelectorAll("Rectangle")
              );
              const rectangles = rectangleNodes.map((rectangleNode) => {
                const rectangleAttrs = {};
                Array.from(rectangleNode.attributes).forEach((attr) => {
                  rectangleAttrs[attr.name] = attr.value;
                });
                return rectangleAttrs;
              });

              return {
                attributes: fieldAttrs,
                polygons,
                circles,
                rectangles,
              };
            });

              return {
                attributes,
                fields,
                visible: true,
              };
            });
          }

          globalMultipleSampling = deriveInitialMultipleSampling(fieldsets);
          if (globalMultipleSamplingInput) {
            globalMultipleSamplingInput.value = globalMultipleSampling;
          }
          applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
          renderFieldsets();
          renderFieldsetDevices();
          renderFieldsetGlobal();
        }

        function findOriginTrace(figure) {
          return figure.data?.find((trace) => {
            const x = trace.x || [];
            const y = trace.y || [];
            return x.length === 1 && y.length === 1 && x[0] === 0 && y[0] === 0;
          });
        }

        function syncPlotSize() {
          if (!plotWrapper) return;
          const width = plotWrapper.clientWidth;
          const computedHeight = Math.max(420, Math.min(900, width * 0.6));
          plotNode.style.height = `${computedHeight}px`;
        }

        if (addScanPlaneBtn) {
          addScanPlaneBtn.addEventListener("click", () => {
            scanPlanes.push(createDefaultScanPlane(scanPlanes.length));
            renderScanPlanes();
          });
        }

        if (scanPlanesContainer) {
          scanPlanesContainer.addEventListener("click", (event) => {
            const addTarget = event.target.closest("[data-action='add-device']");
            if (addTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(addTarget.dataset.planeIndex);
              const plane = scanPlanes[planeIndex];
              if (plane) {
                const newDevice = createDefaultDevice(plane.devices.length);
                plane.devices.push(newDevice);
                renderScanPlanes();
              }
              return;
            }

            const removeDeviceTarget = event.target.closest("[data-action='remove-device']");
            if (removeDeviceTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(removeDeviceTarget.dataset.planeIndex);
              const deviceIndex = Number(removeDeviceTarget.dataset.deviceIndex);
              const plane = scanPlanes[planeIndex];
              if (plane && plane.devices) {
                plane.devices.splice(deviceIndex, 1);
                renderScanPlanes();
              }
              return;
            }

            const removePlaneTarget = event.target.closest("[data-action='remove-scanplane']");
            if (removePlaneTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(removePlaneTarget.dataset.planeIndex);
              scanPlanes.splice(planeIndex, 1);
              renderScanPlanes();
            }
          });

          scanPlanesContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("scanplane-attr")) {
              const planeIndex = Number(target.dataset.planeIndex);
              const field = target.dataset.field;
              updateScanPlaneAttribute(planeIndex, field, target.value);
            } else if (target.classList.contains("device-attr")) {
              const planeIndex = Number(target.dataset.planeIndex);
              const deviceIndex = Number(target.dataset.deviceIndex);
              const field = target.dataset.field;
              updateDeviceAttribute(planeIndex, deviceIndex, field, target.value);
            }
          });
        }

        if (addFieldsetBtn) {
          addFieldsetBtn.addEventListener("click", () => {
            fieldsets.push(createDefaultFieldset(fieldsets.length));
            applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
            renderFieldsets();
          });
        }

        if (globalMultipleSamplingInput) {
          globalMultipleSamplingInput.addEventListener("input", (event) => {
            let value = parseInt(event.target.value, 10);
            if (Number.isNaN(value)) {
              value = 2;
            }
            value = Math.min(16, Math.max(2, value));
            event.target.value = value;
            applyGlobalMultipleSampling(String(value));
            handleTriOrbFieldChange();
          });
        }

        function updateGlobalFieldAttributes() {
          fieldsets.forEach((fieldset) => {
            (fieldset.fields || []).forEach((field) => {
              field.attributes = field.attributes || {};
              field.attributes.MultipleSampling = String(globalMultipleSampling);
              field.attributes.Resolution = String(globalResolution);
              field.attributes.TolerancePositive = String(globalTolerancePositive);
              field.attributes.ToleranceNegative = String(globalToleranceNegative);
            });
          });
        }

        function handleTriOrbFieldChange() {
          updateGlobalFieldAttributes();
          renderFieldsets();
          renderFigure();
        }

        if (globalResolutionInput) {
          globalResolutionInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalResolution);
            globalResolution = Number.isFinite(value) ? value : globalResolution;
            event.target.value = globalResolution;
            handleTriOrbFieldChange();
          });
        }

        if (globalTolerancePositiveInput) {
          globalTolerancePositiveInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalTolerancePositive);
            globalTolerancePositive = Number.isFinite(value) ? value : globalTolerancePositive;
            event.target.value = globalTolerancePositive;
            handleTriOrbFieldChange();
          });
        }

        if (globalToleranceNegativeInput) {
          globalToleranceNegativeInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalToleranceNegative);
            globalToleranceNegative = Number.isFinite(value) ? value : globalToleranceNegative;
            event.target.value = globalToleranceNegative;
            handleTriOrbFieldChange();
          });
        }

        if (fieldOfViewInput) {
          fieldOfViewInput.addEventListener("input", (event) => {
            const nextValue = parseNumeric(event.target.value, fieldOfViewDegrees);
            if (!Number.isFinite(nextValue)) {
              event.target.value = fieldOfViewDegrees;
              return;
            }
            fieldOfViewDegrees = nextValue;
            event.target.value = fieldOfViewDegrees;
            renderFigure();
          });
        }

        if (addFieldsetDeviceBtn) {
          addFieldsetDeviceBtn.addEventListener("click", () => {
            fieldsetDevices.push(createDefaultFieldsetDevice(fieldsetDevices.length));
            renderFieldsetDevices();
            renderFigure();
          });
        }

        if (fieldsetDevicesContainer) {
          fieldsetDevicesContainer.addEventListener("click", (event) => {
            const removeDevice = event.target.closest("[data-action='remove-fieldset-device']");
            if (removeDevice) {
              event.preventDefault();
              event.stopPropagation();
              const deviceIndex = Number(removeDevice.dataset.deviceIndex);
              fieldsetDevices.splice(deviceIndex, 1);
              renderFieldsetDevices();
              renderFigure();
            }
          });

          fieldsetDevicesContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("fieldset-device-typekey")) {
              const deviceIndex = Number(target.dataset.deviceIndex);
              const selectedTypekey = target.value;
              const device = fieldsetDevices[deviceIndex];
              if (device) {
                applyScanPlaneDeviceAttributes(device, selectedTypekey);
                renderFieldsetDevices();
                renderFigure();
              }
            } else if (target.classList.contains("fieldset-device-attr")) {
              const deviceIndex = Number(target.dataset.deviceIndex);
              const field = target.dataset.field;
              updateFieldsetDeviceAttribute(deviceIndex, field, target.value);
            }
          });
        }

        if (fieldsetGlobalContainer) {
          fieldsetGlobalContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("fieldset-global-attr")) {
              const field = target.dataset.field;
              updateGlobalGeometryAttribute(field, target.value);
            }
          });
        }

        function renderFieldsetCheckboxes() {
          if (!fieldsetCheckboxes) {
            return;
          }
          if (!fieldsets.length) {
            fieldsetCheckboxes.innerHTML = "<p>No fieldsets available.</p>";
            return;
          }
            fieldsetCheckboxes.innerHTML = fieldsets
              .map((fieldset, index) => {
                const isVisible = fieldset.visible !== false;
                fieldset.visible = isVisible;
                return `
          <label class="fieldset-checkbox">
            <input
              type="checkbox"
              class="fieldset-filter-checkbox"
              data-fieldset-index="${index}"
              ${isVisible ? "checked" : ""}
            />
            ${escapeHtml(fieldset.attributes?.Name || `Fieldset ${index + 1}`)}
          </label>`;
            })
            .join("");
          renderTriOrbShapeCheckboxes();
        }

        if (fieldsetCheckboxes) {
          fieldsetCheckboxes.addEventListener("change", (event) => {
            if (event.target.classList.contains("fieldset-filter-checkbox")) {
              const index = Number(event.target.dataset.fieldsetIndex);
              const checked = event.target.checked;
              if (fieldsets[index]) {
                fieldsets[index].visible = checked;
              }
              setStatus(
                `Fieldset ${fieldsets[index]?.attributes?.Name || index + 1} ${
                  checked ? "checked" : "unchecked"
                }`,
                "warning"
              );
              renderFigure();
            }
          });
        }

        if (checkAllBtn) {
          checkAllBtn.addEventListener("click", () => {
            toggleAllFieldsetCheckboxes(true);
          });
        }

        if (uncheckAllBtn) {
          uncheckAllBtn.addEventListener("click", () => {
            toggleAllFieldsetCheckboxes(false);
          });
        }

        if (triorbShapeCheckboxes) {
          triorbShapeCheckboxes.addEventListener("change", (event) => {
            if (event.target.classList.contains("triorb-shape-checkbox-input")) {
              const index = Number(event.target.dataset.shapeIndex);
              const shape = triorbShapes[index];
              if (shape) {
                shape.visible = event.target.checked;
              }
              renderFigure();
            }
          });
        }

        if (triorbShapeCheckAllBtn) {
          triorbShapeCheckAllBtn.addEventListener("click", () => {
            setTriOrbShapeVisibility(true);
          });
        }

        if (triorbShapeUncheckAllBtn) {
          triorbShapeUncheckAllBtn.addEventListener("click", () => {
            setTriOrbShapeVisibility(false);
          });
        }

        function addFieldShapeRef(fieldsetIndex, fieldIndex, shapeId) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !shapeId) {
            return;
          }
          field.shapeRefs = field.shapeRefs || [];
          if (field.shapeRefs.some((ref) => ref.shapeId === shapeId)) {
            return;
          }
          field.shapeRefs.push({ shapeId });
          renderFieldsets();
        }

        function removeFieldShapeRef(fieldsetIndex, fieldIndex, shapeIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !Array.isArray(field.shapeRefs)) {
            return;
          }
          field.shapeRefs.splice(shapeIndex, 1);
          renderFieldsets();
        }

        function openTriOrbShapeEditor(shapeId) {
          const shapeIndex = triorbShapes.findIndex((shape) => shape.id === shapeId);
          if (shapeIndex < 0) {
            return;
          }
          const shape = triorbShapes[shapeIndex];
          renderShapeModal({
            kind: (shape.type || "polygon").toLowerCase(),
            shapeIndex,
            shapeType: shape.type,
            isTriOrbShape: true,
          });
        }

        const handleFieldsetInput = (event) => {
          const target = event.target;
          if (!target) return;
          if (target.classList.contains("fieldset-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const field = target.dataset.field;
            updateFieldsetAttribute(fieldsetIndex, field, target.value);
          } else if (target.classList.contains("field-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const field = target.dataset.field;
            updateFieldAttribute(fieldsetIndex, fieldIndex, field, target.value);
          } else if (target.classList.contains("polygon-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const polygonIndex = Number(target.dataset.polygonIndex);
            updatePolygonAttribute(fieldsetIndex, fieldIndex, polygonIndex, "Type", target.value);
          } else if (target.classList.contains("polygon-point")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const polygonIndex = Number(target.dataset.polygonIndex);
            const pointIndex = Number(target.dataset.pointIndex);
            const axis = target.dataset.axis === "Y" ? "Y" : "X";
            updatePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex, axis, target.value);
          } else if (target.classList.contains("rectangle-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const rectangleIndex = Number(target.dataset.rectangleIndex);
            updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, "Type", target.value);
          } else if (target.classList.contains("rectangle-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const rectangleIndex = Number(target.dataset.rectangleIndex);
            const field = target.dataset.field;
            updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, field, target.value);
          } else if (target.classList.contains("circle-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const circleIndex = Number(target.dataset.circleIndex);
            updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, "Type", target.value);
          } else if (target.classList.contains("circle-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const circleIndex = Number(target.dataset.circleIndex);
            const field = target.dataset.field;
            updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, field, target.value);
          }
        };

        if (fieldsetsContainer) {
          fieldsetsContainer.addEventListener("click", (event) => {
            const actionTarget = event.target.closest("[data-action]");
            if (!actionTarget) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            const action = actionTarget.dataset.action;
            switch (action) {
              case "remove-fieldset": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                fieldsets.splice(fieldsetIndex, 1);
                renderFieldsets();
                break;
              }
              case "add-field": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldset = fieldsets[fieldsetIndex];
                if (fieldset) {
                  fieldset.fields = fieldset.fields || [];
                  fieldset.fields.push(createDefaultField(fieldset.fields.length));
                  renderFieldsets();
                }
                break;
              }
              case "remove-field": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const fieldset = fieldsets[fieldsetIndex];
                if (fieldset && fieldset.fields) {
                  fieldset.fields.splice(fieldIndex, 1);
                  renderFieldsets();
                }
                break;
              }
              case "add-field-shape": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const select = actionTarget
                  .closest(".shape-controls")
                  ?.querySelector(".field-shape-selector");
                const shapeId = select?.value;
                addFieldShapeRef(fieldsetIndex, fieldIndex, shapeId);
                break;
              }
              case "remove-field-shape": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const shapeIndex = Number(actionTarget.dataset.shapeIndex);
                removeFieldShapeRef(fieldsetIndex, fieldIndex, shapeIndex);
                break;
              }
              case "edit-field-shape": {
                openTriOrbShapeEditor(actionTarget.dataset.shapeId);
                break;
              }
              default:
                break;
            }
          });

          fieldsetsContainer.addEventListener("input", (event) => {
            handleFieldsetInput(event);
          });
          fieldsetsContainer.addEventListener("change", (event) => {
            handleFieldsetInput(event);
          });
        }

        let triOrbSpinnerTimer = null;
        let triOrbSpinnerStep = null;

        if (triorbShapesContainer) {
          triorbShapesContainer.addEventListener("pointerdown", (event) => {
            const target = event.target;
            if (
              target instanceof HTMLInputElement &&
              target.type === "number" &&
              target.closest(".triorb-shape-card")
            ) {
              const rect = target.getBoundingClientRect();
              const isUp = event.clientY < rect.top + rect.height / 2;
              const stepFn = () => {
                if (isUp) {
                  target.stepUp();
                } else {
                  target.stepDown();
                }
                handleTriOrbShapeInput({ target });
              };
              stepFn();
              triOrbSpinnerStep = stepFn;
              triOrbSpinnerTimer = setInterval(stepFn, 140);
            }
          });
          document.addEventListener("pointerup", () => {
            if (triOrbSpinnerTimer) {
              clearInterval(triOrbSpinnerTimer);
              triOrbSpinnerTimer = null;
              triOrbSpinnerStep = null;
            }
          });
          triorbShapesContainer.addEventListener("input", (event) => {
            handleTriOrbShapeInput(event);
          });
          triorbShapesContainer.addEventListener("change", (event) => {
            handleTriOrbShapeInput(event);
          });
          triorbShapesContainer.addEventListener("click", (event) => {
            if (!event.target) return;
            const action = event.target.dataset.action;
            if (action === "remove-triorb-shape") {
              const index = Number(event.target.dataset.shapeIndex);
              removeTriOrbShape(index);
            }
          });
        }

        if (addTriOrbShapeBtn) {
          addTriOrbShapeBtn.addEventListener("click", () => {
            triorbShapes.push(createDefaultTriOrbShape(triorbShapes.length));
            renderTriOrbShapes();
            renderTriOrbShapeCheckboxes();
            renderFieldsets();
          });
        }

        function toggleAllFieldsetCheckboxes(checked) {
          if (!fieldsetCheckboxes) return;
          const boxes = fieldsetCheckboxes.querySelectorAll(".fieldset-filter-checkbox");
          boxes.forEach((box) => {
            box.checked = checked;
            const index = Number(box.dataset.fieldsetIndex);
            if (fieldsets[index]) {
              fieldsets[index].visible = checked;
            }
          });
          setStatus(
            checked ? "All fieldsets checked." : "All fieldsets unchecked.",
            checked ? "ok" : "warning"
          );
          renderFigure();
        }

        function renderTriOrbShapeCheckboxes() {
          if (!triorbShapeCheckboxes) {
            return;
          }
          if (!triorbShapes.length) {
            triorbShapeCheckboxes.innerHTML = "<p>No shapes available.</p>";
            return;
          }
          triorbShapeCheckboxes.innerHTML = triorbShapes
            .map((shape, index) => {
              const isVisible = shape.visible !== false;
              shape.visible = isVisible;
              return `
                <label class="triorb-shape-checkbox">
                  <input
                    type="checkbox"
                    class="triorb-shape-checkbox-input"
                    data-shape-index="${index}"
                    ${isVisible ? "checked" : ""}
                  />
                  ${escapeHtml(shape.name || `Shape ${index + 1}`)}
                </label>`;
            })
            .join("");
        }

        function setTriOrbShapeVisibility(visible) {
          triorbShapes.forEach((shape) => {
            shape.visible = visible;
          });
          renderTriOrbShapeCheckboxes();
          renderFigure();
        }

        function removeTriOrbShape(shapeIndex) {
          if (!Number.isFinite(shapeIndex) || shapeIndex < 0 || shapeIndex >= triorbShapes.length) {
            return;
          }
          const removedShape = triorbShapes[shapeIndex];
          triorbShapes.splice(shapeIndex, 1);
          fieldsets.forEach((fieldset) => {
            (fieldset.fields || []).forEach((field) => {
              if (Array.isArray(field.shapeRefs)) {
                field.shapeRefs = field.shapeRefs.filter(
                  (ref) => ref.shapeId !== removedShape.id
                );
              }
            });
          });
          renderTriOrbShapes();
          renderTriOrbShapeCheckboxes();
          renderFieldsets();
          renderFigure();
        }

        if (saveTriOrbBtn) {
          saveTriOrbBtn.addEventListener("click", () => {
            const xml = buildTriOrbXml();
            downloadXml(xml);
            setStatus("TriOrb XML downloaded.");
          });
        }
        if (saveLegacyBtn) {
          saveLegacyBtn.addEventListener("click", () => {
            const xml = buildLegacyXml();
            downloadXml(xml);
            setStatus("Legacy XML downloaded.");
          });
        }

        if (toggleLegendBtn) {
          toggleLegendBtn.addEventListener("click", () => {
            legendVisible = !legendVisible;
            toggleLegendBtn.textContent = legendVisible ? "Hide Legend" : "Show Legend";
            setStatus(legendVisible ? "Legend visible." : "Legend hidden.", legendVisible ? "ok" : "warning");
            renderFigure();
          });
        }

        fileInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = () => {
            try {
              const { traces, warning } = parseXmlToFigure(reader.result);
              const layout = cloneFigure(defaultFigure).layout;
              currentFigure = { data: traces, layout };
              renderFigure();
              if (warning) {
                setStatus(`${file.name} loaded with warnings: ${warning}`, "warning");
              } else {
                setStatus(`${file.name} loaded.`);
              }
            } catch (error) {
              console.error(error);
              setStatus(error.message || "Failed to load file.", "error");
            } finally {
              fileInput.value = "";
            }
          };
          reader.readAsText(file, "utf-8");
        });

        window.addEventListener("resize", () => {
          syncPlotSize();
          Plotly.Plots.resize(plotNode);
        });

        plotNode.on("plotly_hover", (event) => {
          if (event?.points?.length) {
            lastHoverPoint = event.points[0];
          }
        });

        plotNode.on("plotly_click", (event) => {
          const point = event?.points?.[0] || lastHoverPoint;
          console.debug("plotly_click", { point, lastHoverPoint });
          const meta = point?.meta || point?.data?.meta;
          if (meta?.kind) {
            console.debug("trigger modal", meta);
            renderShapeModal(meta);
          }
        });
        if (shapeModal) {
          shapeModal.addEventListener("click", (event) => {
            if (event.target?.dataset?.action === "close-modal") {
              cancelShapeModal();
            }
          });
        }
        if (shapeModalBody) {
          shapeModalBody.addEventListener("input", handleShapeModalInput);
        }
        if (shapeModalCancel) {
          shapeModalCancel.addEventListener("click", cancelShapeModal);
        }
        if (shapeModalClose) {
          shapeModalClose.addEventListener("click", cancelShapeModal);
        }
        if (shapeModalSave) {
          shapeModalSave.addEventListener("click", saveShapeModal);
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            cancelShapeModal();
          }
        });
        if (shapeModalHeader) {
          shapeModalHeader.addEventListener("pointerdown", startModalDrag);
        }
        document.addEventListener("pointermove", updateModalDrag);
        document.addEventListener("pointerup", endModalDrag);

        setupLayoutObservers();
        renderFigure();

        function setupLayoutObservers() {
          if (typeof ResizeObserver === "undefined") {
            return;
          }
          const observer = new ResizeObserver(() => {
            syncPlotSize();
            Plotly.Plots.resize(plotNode);
          });
          const contentArea = document.querySelector(".content-area");
          const sideMenu = document.querySelector(".side-menu");
          if (contentArea) observer.observe(contentArea);
          if (sideMenu) observer.observe(sideMenu);
        }
      });
    </script>
  </body>
</html>