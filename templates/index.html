<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SICK SLS Editor (Web)</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.ico') }}" />
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", "Yu Gothic UI", system-ui, -apple-system, sans-serif;
      }


      body {
        margin: 0;
        background: #eef1f5;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        background: #0b6fb8;
        color: #fff;
        padding: 1rem 1.5rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      header p {
        margin: 0.2rem 0 0;
      }

      main {
        width: 95%;
        margin: 2rem auto;
        padding: 1.5rem;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(15, 23, 42, 0.1);
        flex: 1;
        display: flex;
        gap: 1.5rem;
        align-items: flex-start;
      }

      .content-area {
        flex: 1 1 65%;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .side-menu {
        flex: 0 0 360px;
        max-height: calc(100vh - 4rem);
        overflow-y: auto;
        padding-right: 0.5rem;
        position: sticky;
        top: 2rem;
        align-self: flex-start;
      }

      .side-menu::-webkit-scrollbar {
        width: 6px;
      }

      .side-menu::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.25);
        border-radius: 3px;
      }

      .toolbar {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .toolbar-primary {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .toolbar-toggle {
        width: 100%;
        display: flex;
        justify-content: flex-start;
      }

      button,
      label.upload-btn,
      .inline-btn {
        border: none;
        border-radius: 6px;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        cursor: pointer;
        background: #0b6fb8;
        color: #fff;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        box-shadow: 0 1px 3px rgba(15, 23, 42, 0.2);
      }

      .legend-toggle-btn {
        background: #475569;
        font-size: 0.75rem;
        padding: 0.35rem 0.75rem;
        color: #e2e8f0;
      }

      button.secondary {
        background: #475569;
      }

      .inline-btn.inline-danger {
        background: #c53030;
      }
      label.upload-btn {
        position: relative;
      }

      label.upload-btn input[type="file"] {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      #status-text {
        margin-left: auto;
        font-size: 0.9rem;
        color: #475569;
      }

      #status-text[data-state="error"] {
        color: #c53030;
      }

      #status-text[data-state="warning"] {
        color: #d97706;
      }

      .plot-wrapper {
        width: 100%;
        max-width: none;
        min-height: 420px;
      }

      #plot {
        width: 100%;
        min-height: 520px;
        height: clamp(420px, 65vh, 900px);
      }

      .fieldset-filter {
        margin-top: 1rem;
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.75rem;
        background: #f8fafc;
      }

      .fieldset-filter-controls {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      #fieldset-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
      }

      .fieldset-checkbox {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.9rem;
      }

      .side-menu {
        flex: 0 0 auto;
        min-width: 220px;
        max-width: 40%;
        width: fit-content;
        background: #f6f8fb;
        border-radius: 10px;
        padding: 1rem;
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
      }

      .side-menu h2 {
        font-size: 1rem;
        margin: 0 0 0.75rem;
        color: #1f2937;
      }

      .menu-section {
        border: 1px solid rgba(15, 23, 42, 0.08);
        border-radius: 8px;
        margin-bottom: 0.5rem;
        background: #fff;
      }

      .menu-section summary {
        cursor: pointer;
        padding: 0.6rem 0.8rem;
        font-weight: 600;
        color: #0b6fb8;
        list-style: none;
      }

      .menu-section summary::-webkit-details-marker {
        display: none;
      }

      .menu-section summary::after {
        content: "+";
        float: right;
        font-weight: normal;
        color: #64748b;
      }

      .menu-section[open] summary::after {
        content: "-";
      }

      .menu-content {
        padding: 0.6rem 0.8rem 1rem;
        color: #475569;
        font-size: 0.9rem;
        border-top: 1px solid rgba(15, 23, 42, 0.06);
      }

      .menu-description {
        margin: 0 0 0.6rem;
        color: #1f2937;
        font-weight: 500;
      }

      .menu-fileinfo-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 0.7rem 1rem;
      }

      .menu-fileinfo-field label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
      }

      .menu-fileinfo-field input {
        width: 100%;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        background: #fff;
      }

      .triorb-field label {
        display: block;
        margin-bottom: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
      }

      .triorb-field input,
      .triorb-field select {
        width: 100%;
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        background: #e6f2ff;
      }

      .menu-fileinfo-field input:focus,
      .scanplane-card input:focus,
      .device-card input:focus,
      .fieldset-field input:focus,
      .field-attribute input:focus {
        outline: 2px solid rgba(11, 111, 184, 0.35);
        border-color: rgba(11, 111, 184, 0.65);
      }

      .scanplanes-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .scanplane-card,
      .device-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.6rem;
        background: #fefefe;
      }

      .scanplane-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: #0b6fb8;
        cursor: pointer;
      }

      .scanplane-details summary::-webkit-details-marker {
        display: none;
      }

      .scanplane-summary {
        font-size: 0.85rem;
        color: #475569;
      }

      .scanplane-fields,
      .device-fields {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.4rem 0.6rem;
      }

      .scanplane-field,
      .device-field {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .scanplane-field label,
      .device-field label {
        margin-bottom: 0.2rem;
        font-weight: 600;
        color: #475569;
      }

      .scanplane-field input,
      .device-field input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .device-card {
        margin-top: 0.5rem;
        background: #fff;
      }

      .device-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #334155;
        cursor: pointer;
      }

      .device-details summary::-webkit-details-marker {
        display: none;
      }

      .device-summary {
        font-size: 0.8rem;
        color: #64748b;
      }

      select {
        background: #e6f2ff;
      }

      .fieldsets-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .fieldset-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.6rem;
        background: #fff;
      }

      .fieldset-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .fieldset-details summary::-webkit-details-marker {
        display: none;
      }

      .fieldset-summary {
        font-size: 0.8rem;
        color: #475569;
        margin-left: 0.5rem;
      }

      .fieldset-fields,
      .field-attributes {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.5rem;
      }

      .fieldset-field,
      .field-attribute {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
      }

      .debug-hidden {
        display: none !important;
      }

      body.debug-mode .debug-hidden {
        display: flex !important;
      }

      .fieldset-field label,
      .field-attribute label {
        margin-bottom: 0.2rem;
        font-weight: 600;
        color: #475569;
      }

      .fieldset-field input,
      .field-attribute input {
        border-radius: 6px;
        border: 1px solid rgba(15, 23, 42, 0.2);
        padding: 0.35rem 0.45rem;
        font-size: 0.85rem;
      }

      .field-card {
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 8px;
        padding: 0.5rem;
        background: #fefefe;
        margin-top: 0.5rem;
      }

      .field-details summary {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #0d4b91;
        cursor: pointer;
      }

      .field-details summary::-webkit-details-marker {
        display: none;
      }

      .field-summary {
        font-size: 0.8rem;
        color: #64748b;
        margin-left: 0.5rem;
      }

      .shape-section {
        margin-top: 0.5rem;
      }

      .shape-list {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .shape-entry {
        border: 1px dashed rgba(15, 23, 42, 0.2);
        border-radius: 6px;
        padding: 0.4rem 0.5rem;
        background: #f9fafb;
      }

      .shape-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
        color: #475569;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .shape-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        font-size: 0.75rem;
      }

      .shape-points {
        margin-top: 0.25rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        font-size: 0.8rem;
        color: #475569;
      }

      .shape-point {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        align-items: center;
      }

      .shape-point label {
        margin: 0;
        font-weight: 500;
      }

      .shape-point input {
        width: 5rem;
      }

      .fieldset-actions,
      .field-actions {
        margin-top: 0.5rem;
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
      }

      .shape-actions {
        margin-top: 0.5rem;
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
        justify-content: flex-start;
      }

      .fieldset-global-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.4rem 0.6rem;
      }

      .scanplane-actions {
        margin-top: 0.6rem;
        display: flex;
        justify-content: flex-end;
      }

      .device-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.4rem;
        font-weight: 600;
        color: #334155;
      }

      .shape-mini-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
      }

      footer {
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
        margin-bottom: 2rem;
      }

      @media (max-width: 960px) {
        main {
          flex-direction: column;
        }

        .side-menu {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>TriOrb - SICK SLS Editor</h1>
    </header>
    <main>
      <section class="content-area">
        <div class="toolbar">
          <div class="toolbar-primary">
            <button id="btn-new" type="button">New Plot</button>
            <button id="btn-save" type="button" class="secondary">Save (XML)</button>
            <label class="upload-btn">
              Load (XML)
              <input id="file-input" type="file" accept=".xml,.sgexml" />
            </label>
            <span id="status-text">Ready</span>
          </div>
          <div class="toolbar-toggle">
            <button id="btn-toggle-legend" type="button" class="legend-toggle-btn">Hide Legend</button>
          </div>
        </div>
        <div class="plot-wrapper">
          <div id="plot"></div>
        </div>
        <div class="fieldset-filter">
          <div class="fieldset-filter-controls">
            <button type="button" class="inline-btn" id="btn-fieldset-check-all">All check</button>
            <button type="button" class="inline-btn" id="btn-fieldset-uncheck-all">All uncheck</button>
          </div>
          <div id="fieldset-checkboxes"></div>
        </div>
      </section>
      <aside class="side-menu">
        <h2>Structure Menu</h2>
        {% for item in menu_items %}
        {% if item.tag == "FileInfo" %}
        <details class="menu-section">
        {% else %}
        <details class="menu-section" {% if loop.first %}open{% endif %}>
        {% endif %}
          <summary>{{ item.tag }}</summary>
          <div class="menu-content">
            {% if item.tag == "FileInfo" %}
              <p class="menu-description">{{ item.summary }}</p>
              {% if fileinfo_fields %}
              <div class="menu-fileinfo-grid" data-scope="fileinfo">
                {% for field in fileinfo_fields %}
                <div class="menu-fileinfo-field">
                  <label for="fileinfo-{{ field.tag }}">{{ field.tag }}</label>
                  <input
                    id="fileinfo-{{ field.tag }}"
                    type="text"
                    value="{{ field.value }}"
                    data-field="{{ field.tag }}"
                  />
                </div>
                {% endfor %}
              </div>
              {% else %}
              <p>No FileInfo entries.</p>
              {% endif %}
            {% elif item.tag == "Export_ScanPlanes" %}
              <p class="menu-description">{{ item.summary }}</p>
              <button type="button" class="inline-btn" id="btn-add-scanplane">Add ScanPlane</button>
              <div class="scanplanes-editor" id="scanplanes-editor"></div>
            {% elif item.tag == "Export_FieldsetsAndFields" %}
              <p class="menu-description">{{ item.summary }}</p>
              <button type="button" class="inline-btn" id="btn-add-fieldset">Add Fieldset</button>
              <details class="menu-section" id="fieldset-global-section">
                <summary>GlobalGeometry</summary>
                <div class="menu-content">
                  <div class="fieldset-global-grid" id="fieldset-global"></div>
                </div>
              </details>
              <details class="menu-section" id="fieldset-devices-section">
                <summary>Devices</summary>
                <div class="menu-content">
                  <div class="fieldset-actions">
                    <button type="button" class="inline-btn" id="btn-add-fieldset-device">
                      Add Device
                    </button>
                  </div>
                  <div class="fieldsets-editor" id="fieldset-devices"></div>
                </div>
              </details>
              <div class="fieldsets-editor" id="fieldsets-editor"></div>
            {% else %}
              <p>{{ item.summary }}</p>
            {% endif %}
          </div>
        </details>
        {% endfor %}
        <h2>TriOrb Menu</h2>
        <details class="menu-section">
          <summary>Device</summary>
          <div class="menu-content">
            <div class="menu-fileinfo-grid">
              <div class="triorb-field">
                <label>FieldOfView</label>
                <input
                  type="number"
                  id="triorb-field-of-view"
                  value="270"
                  min="1"
                  max="360"
                  step="1"
                />
              </div>
            </div>
          </div>
        </details>
        <details class="menu-section">
          <summary>Field</summary>
          <div class="menu-content">
            <div class="menu-fileinfo-grid">
              <div class="triorb-field">
                <label>MultipleSampling (2-16)</label>
                <input
                  id="global-multiple-sampling"
                  type="number"
                  min="2"
                  max="16"
                  value="2"
                />
              </div>
              <div class="triorb-field">
                <label>Resolution</label>
                <input
                  id="global-resolution"
                  type="number"
                  min="1"
                  max="1000"
                  value="70"
                />
              </div>
              <div class="triorb-field">
                <label>TolerancePositive</label>
                <input
                  id="global-tolerance-positive"
                  type="number"
                  value="0"
                />
              </div>
              <div class="triorb-field">
                <label>ToleranceNegative</label>
                <input
                  id="global-tolerance-negative"
                  type="number"
                  value="0"
                />
              </div>
            </div>
            <details class="menu-section">
              <summary>CommonCutOut #1</summary>
              <div class="menu-content">
                <ul>
                  <li>Polygon #1</li>
                  <li>Circle #1</li>
                  <li>Rectangle #1</li>
                </ul>
              </div>
            </details>
          </div>
        </details>
      </aside>
    </main>
    <footer>Flask + Plotly powered preview</footer>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const defaultFigure = {{ plot_spec|tojson }};
        defaultFigure.data = defaultFigure.data || [];
        const rootAttributes = {{ root_attrs|tojson }};
        const initialScanPlanes = {{ scan_planes|tojson }};
        const fieldsetData = {{ fieldsets|tojson }};
        const initialFieldsets = fieldsetData.fieldsets || [];
        const initialFieldsetDevices = fieldsetData.devices || [];
        const initialFieldsetGlobal = fieldsetData.global_geometry || {};

        const figureConfig = { responsive: true, displaylogo: false };
        const fieldsetColorPalette = [
          "#2563eb",
          "#f43f5e",
          "#10b981",
          "#f97316",
          "#c084fc",
          "#14b8a6",
          "#facc15",
          "#8b5cf6",
        ];
        const circleSampleSegments = 72;
        const legendLabelMaxLength = 36;
        const defaultScanDeviceTemplates = [
          { DeviceName: "Right" },
          { DeviceName: "Left" },
        ];
        const defaultFieldsetDeviceTemplates = [
          { PositionX: "170", PositionY: "156", Rotation: "290", StandingUpsideDown: "true" },
          { PositionX: "-170", PositionY: "156", Rotation: "70", StandingUpsideDown: "true" },
        ];
        const shapeTypeOptions = {
          polygon: ["CutOut", "Field"],
          rectangle: ["Field"],
          circle: ["Field"],
        };
        const plotNode = document.getElementById("plot");
        const statusText = document.getElementById("status-text");
        const fileInput = document.getElementById("file-input");
        const plotWrapper = document.querySelector(".plot-wrapper");
        const scanPlanesContainer = document.getElementById("scanplanes-editor");
        const addScanPlaneBtn = document.getElementById("btn-add-scanplane");
        const fieldsetsContainer = document.getElementById("fieldsets-editor");
        const fieldsetDevicesContainer = document.getElementById("fieldset-devices");
        const addFieldsetDeviceBtn = document.getElementById("btn-add-fieldset-device");
        const fieldsetGlobalContainer = document.getElementById("fieldset-global");
        const addFieldsetBtn = document.getElementById("btn-add-fieldset");
        const globalMultipleSamplingInput = document.getElementById("global-multiple-sampling");
        const fieldsetCheckboxes = document.getElementById("fieldset-checkboxes");
        const checkAllBtn = document.getElementById("btn-fieldset-check-all");
        const uncheckAllBtn = document.getElementById("btn-fieldset-uncheck-all");
        const toggleLegendBtn = document.getElementById("btn-toggle-legend");
        const fieldOfViewInput = document.getElementById("triorb-field-of-view");
        const globalResolutionInput = document.getElementById("global-resolution");
        const globalTolerancePositiveInput = document.getElementById("global-tolerance-positive");
        const globalToleranceNegativeInput = document.getElementById("global-tolerance-negative");
        const originTrace = findOriginTrace(defaultFigure);

        let currentFigure = cloneFigure(defaultFigure);
        let scanPlanes = initializeScanPlanes(initialScanPlanes);
        let fieldsets = initializeFieldsets(initialFieldsets);
        let fieldsetDevices = initializeFieldsetDevices(initialFieldsetDevices);
        let fieldsetGlobalGeometry = initializeGlobalGeometry(initialFieldsetGlobal);
        let globalMultipleSampling = deriveInitialMultipleSampling(fieldsets);
        let legendVisible = true;
        let fieldOfViewDegrees = parseNumeric(fieldOfViewInput?.value, 270);
        const debugMode = Boolean(new URLSearchParams(window.location.search).get("debug"));
        if (debugMode) {
          document.body.classList.add("debug-mode");
        }
        let globalResolution = parseNumeric(globalResolutionInput?.value, 70);
        let globalTolerancePositive = parseNumeric(globalTolerancePositiveInput?.value, 0);
        let globalToleranceNegative = parseNumeric(globalToleranceNegativeInput?.value, 0);
        globalResolution = deriveFieldAttribute(fieldsets, "Resolution", globalResolution);
        globalTolerancePositive = deriveFieldAttribute(fieldsets, "TolerancePositive", globalTolerancePositive);
        globalToleranceNegative = deriveFieldAttribute(fieldsets, "ToleranceNegative", globalToleranceNegative);
        applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
        if (globalMultipleSamplingInput) {
          globalMultipleSamplingInput.value = globalMultipleSampling;
        }
        if (globalResolutionInput) {
          globalResolutionInput.value = globalResolution;
        }
        if (globalTolerancePositiveInput) {
          globalTolerancePositiveInput.value = globalTolerancePositive;
        }
        if (globalToleranceNegativeInput) {
          globalToleranceNegativeInput.value = globalToleranceNegative;
        }
        updateGlobalFieldAttributes();

        renderScanPlanes();
        renderFieldsets();
        renderFieldsetDevices();
        renderFieldsetGlobal();
        renderFieldsetCheckboxes();

        function initializeScanPlanes(data) {
          let planes;
          if (!Array.isArray(data) || !data.length) {
            planes = [createDefaultScanPlane(0)];
          } else {
            planes = data.map((plane, index) => ({
              attributes: { ...(plane.attributes || {}), Index: plane.attributes?.Index ?? String(index) },
              devices: Array.isArray(plane.devices)
                ? plane.devices.map((device, dIdx) => ({
                    attributes: { ...(device.attributes || {}), Index: device.attributes?.Index ?? String(dIdx) },
                  }))
                : [],
            }));
          }
          planes.forEach(ensureDefaultScanDevices);
          return planes;
        }

        function cloneFigure(figure) {
          return JSON.parse(JSON.stringify(figure));
        }

        function setStatus(message, state = "ok") {
          statusText.textContent = message;
          const resolvedState =
            typeof state === "string" ? state : state ? "error" : "ok";
          statusText.dataset.state = resolvedState;
        }

        function renderFigure() {
          syncPlotSize();
          const baseData = (currentFigure.data || []).map((trace, index) => {
            const copy = { ...trace };
            const originalName = copy.name || `Trace ${index + 1}`;
            copy.name = formatLegendLabel(originalName);
            return copy;
          });
          const overlayTraces = buildFieldsetTraces();
          const layout = {
            ...(currentFigure.layout || {}),
            showlegend: legendVisible,
            legend: {
              ...(currentFigure.layout?.legend || {}),
              x: 0,
              y: 1,
              xanchor: "left",
              yanchor: "top",
              orientation: "v",
              bgcolor: "rgba(255, 255, 255, 0.88)",
              borderwidth: 0,
              font: {
                ...(currentFigure.layout?.legend?.font || {}),
                size: 11,
                color: "#0f172a",
              },
            },
          };
          Plotly.react(plotNode, baseData.concat(overlayTraces), layout, figureConfig);
        }

        function buildFieldsetTraces() {
          if (!Array.isArray(fieldsets) || !fieldsets.length) {
            return [];
          }
          const traces = [];
          fieldsets.forEach((fieldset, fieldsetIndex) => {
            if (!fieldset || fieldset.visible === false) {
              return;
            }
            const fieldsetName = fieldset.attributes?.Name || `Fieldset ${fieldsetIndex + 1}`;
            (fieldset.fields || []).forEach((field, fieldIndex) => {
              const fieldName = field.attributes?.Name || `Field ${fieldIndex + 1}`;
              const labelPrefix = `${fieldsetName} / ${fieldName}`;
              const color = getFieldsetColor(fieldsetIndex + fieldIndex);

              (field.polygons || []).forEach((polygon, polygonIndex) => {
                const polygonTrace = buildPolygonTrace(
                  polygon,
                  color,
                  `${labelPrefix} Polygon #${polygonIndex + 1}`,
                  field.attributes?.Fieldtype
                );
                if (polygonTrace) {
                  traces.push(polygonTrace);
                }
              });

              (field.rectangles || []).forEach((rectangle, rectangleIndex) => {
                const rectangleTrace = buildRectangleTrace(
                  rectangle,
                  color,
                  `${labelPrefix} Rectangle #${rectangleIndex + 1}`,
                  field.attributes?.Fieldtype
                );
                if (rectangleTrace) {
                  traces.push(rectangleTrace);
                }
              });

              (field.circles || []).forEach((circle, circleIndex) => {
                const circleTrace = buildCircleTrace(
                  circle,
                  color,
                  `${labelPrefix} Circle #${circleIndex + 1}`,
                  field.attributes?.Fieldtype
                );
                if (circleTrace) {
                  traces.push(circleTrace);
                }
              });
            });
          });
          const deviceTraces = buildDeviceOverlayTraces();
          return deviceTraces.concat(traces);
        }

        function buildPolygonTrace(polygon, color, label, fieldType) {
          const points = Array.isArray(polygon?.points) ? polygon.points : [];
          if (points.length < 2) {
            return null;
          }
          const coords = points.map((point) => ({
            x: parseNumeric(point.X, 0),
            y: parseNumeric(point.Y, 0),
          }));
          if (!coords.length) {
            return null;
          }
          const x = coords.map((point) => point.x);
          const y = coords.map((point) => point.y);
          const first = coords[0];
          const last = coords[coords.length - 1];
          if (first.x !== last.x || first.y !== last.y) {
            x.push(first.x);
            y.push(first.y);
          } else {
            x.push(first.x);
            y.push(first.y);
          }
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, polygon?.attributes?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.12),
            name: truncatedLabel,
            meta: { fullLabel: label },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x,
            y,
          };
        }

        function buildRectangleTrace(rectangle, color, label, fieldType) {
          const corners = getRectangleCornerPoints(rectangle);
          if (!corners || !corners.length) {
            return null;
          }
          const rotated = corners.concat(corners[0]);
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, rectangle?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.08),
            name: truncatedLabel,
            meta: { fullLabel: label },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x: rotated.map((point) => point.x),
            y: rotated.map((point) => point.y),
          };
        }

        function buildCircleTrace(circle, color, label, fieldType) {
          if (!circle) {
            return null;
          }
          const radius = parseNumeric(circle.Radius, NaN);
          if (!Number.isFinite(radius) || radius <= 0) {
            return null;
          }
          const centerX = parseNumeric(circle.CenterX, 0);
          const centerY = parseNumeric(circle.CenterY, 0);
          const x = [];
          const y = [];
          for (let i = 0; i <= circleSampleSegments; i += 1) {
            const angle = (i / circleSampleSegments) * Math.PI * 2;
            x.push(centerX + radius * Math.cos(angle));
            y.push(centerY + radius * Math.sin(angle));
          }
          const truncatedLabel = formatLegendLabel(label);
          const style = resolveShapeStyle(fieldType, circle?.Type);
          return {
            type: "scatter",
            mode: "lines",
            line: { color, width: style.lineWidth, dash: style.lineDash },
            fill: "toself",
            fillcolor: withAlpha(color, 0.08),
            name: truncatedLabel,
            meta: { fullLabel: label },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x,
            y,
          };
        }

        function getRectangleCornerPoints(rectangle) {
          if (!rectangle) {
            return null;
          }
          const width = parseNumeric(rectangle.Width, NaN);
          const height = parseNumeric(rectangle.Height, NaN);
          if (!Number.isFinite(width) || !Number.isFinite(height) || width === 0 || height === 0) {
            return null;
          }
          const originX = parseNumeric(rectangle.OriginX, 0);
          const originY = parseNumeric(rectangle.OriginY, 0);
          const rotationDeg = parseNumeric(rectangle.Rotation, 0);
          const rotation = degreesToRadians(rotationDeg);
          const topLeft = { x: originX, y: originY };
          const topRight = { x: originX + width, y: originY };
          const bottomRight = { x: originX + width, y: originY - height };
          const bottomLeft = { x: originX, y: originY - height };
          const corners = [topLeft, topRight, bottomRight, bottomLeft];
          if (rotation === 0) {
            return corners;
          }
          return corners.map((corner) => rotateAroundCorner(corner, rotation, topLeft));
        }

        function rotatePoint(x, y, radians, originX, originY) {
          const cos = Math.cos(radians);
          const sin = Math.sin(radians);
          return {
            x: originX + x * cos - y * sin,
            y: originY + x * sin + y * cos,
          };
        }

        function rotateAroundCorner(point, radians, origin) {
          const translatedX = point.x - origin.x;
          const translatedY = point.y - origin.y;
          const rotated = rotatePoint(translatedX, translatedY, radians, 0, 0);
          return {
            x: rotated.x + origin.x,
            y: rotated.y + origin.y,
          };
        }

        function degreesToRadians(value) {
          return (Number(value) * Math.PI) / 180;
        }

        function normalizeDegrees(value) {
          const deg = Number(value);
          if (!Number.isFinite(deg)) {
            return 0;
          }
          const normalized = deg % 360;
          return normalized < 0 ? normalized + 360 : normalized;
        }

        function parseNumeric(value, fallback = NaN) {
          const num = Number.parseFloat(value);
          return Number.isFinite(num) ? num : fallback;
        }

        function withAlpha(color, alpha) {
          if (!color || typeof color !== "string") {
            return `rgba(15, 23, 42, ${alpha})`;
          }
          if (!color.startsWith("#")) {
            return color;
          }
          let hex = color.replace("#", "").trim();
          if (hex.length === 3) {
            hex = hex
              .split("")
              .map((ch) => ch + ch)
              .join("");
          }
          if (hex.length !== 6) {
            return color;
          }
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getFieldsetColor(index) {
          if (!Array.isArray(fieldsetColorPalette) || !fieldsetColorPalette.length) {
            return "#0f172a";
          }
          const safeIndex = Number.isFinite(index) && index >= 0 ? index : 0;
          return fieldsetColorPalette[safeIndex % fieldsetColorPalette.length];
        }

        function calculateVisibleFieldsetRadius() {
          let maxDistance = 0;
          fieldsets.forEach((fieldset) => {
            if (fieldset.visible === false) {
              return;
            }
            (fieldset.fields || []).forEach((field) => {
              (field.polygons || []).forEach((polygon) => {
                (polygon.points || []).forEach((point) => {
                  const x = parseNumeric(point.X, 0);
                  const y = parseNumeric(point.Y, 0);
                  const dist = Math.hypot(x, y);
                  if (dist > maxDistance) {
                    maxDistance = dist;
                  }
                });
              });
              (field.rectangles || []).forEach((rectangle) => {
                const corners = getRectangleCornerPoints(rectangle) || [];
                corners.forEach((corner) => {
                  const dist = Math.hypot(corner.x, corner.y);
                  if (dist > maxDistance) {
                    maxDistance = dist;
                  }
                });
              });
              (field.circles || []).forEach((circle) => {
                const centerX = parseNumeric(circle.CenterX, 0);
                const centerY = parseNumeric(circle.CenterY, 0);
                const radius = Math.max(0, parseNumeric(circle.Radius, 0));
                const dist = Math.hypot(centerX, centerY) + radius;
                if (dist > maxDistance) {
                  maxDistance = dist;
                }
              });
            });
          });
          return maxDistance;
        }

        function calculateDeviceFanRadius() {
          const visibleRadius = calculateVisibleFieldsetRadius();
          if (!Number.isFinite(visibleRadius) || visibleRadius <= 0) {
            return 1000;
          }
          return visibleRadius + 500;
        }

        function buildDeviceOverlayTraces() {
          if (!Array.isArray(fieldsetDevices) || !fieldsetDevices.length) {
            return [];
          }
          const radius = calculateDeviceFanRadius();
          const traces = [];
          fieldsetDevices.forEach((device, deviceIndex) => {
            const attrs = device?.attributes || {};
            const x = parseNumeric(attrs.PositionX, NaN);
            const y = parseNumeric(attrs.PositionY, NaN);
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
              return;
            }
            const deviceLabel =
              attrs.Typekey ||
              attrs.DeviceName ||
              `Device ${deviceIndex + 1}`;
            traces.push({
              type: "scatter",
              mode: "markers",
              marker: { color: "#111", size: 8 },
              name: formatLegendLabel(`${deviceLabel} position`),
              meta: { fullLabel: deviceLabel },
              hovertemplate:
                "<b>%{meta.fullLabel}</b><br>X: %{x}<br>Y: %{y}<extra></extra>",
              x: [x],
              y: [y],
              showlegend: false,
            });
            const rotation = parseNumeric(attrs.Rotation, 0);
            if (
              Number.isFinite(radius) &&
              radius > 0 &&
              Number.isFinite(fieldOfViewDegrees) &&
              fieldOfViewDegrees > 0
            ) {
              const fanTrace = buildDeviceFanTrace(
                x,
                y,
                rotation,
                radius,
                fieldOfViewDegrees,
                deviceLabel
              );
              if (fanTrace) {
                traces.push(fanTrace);
              }
            }
          });
          return traces;
        }

        function buildDeviceFanTrace(originX, originY, rotationDeg, radius, fovDeg, label) {
          if (
            !Number.isFinite(radius) ||
            radius <= 0 ||
            !Number.isFinite(fovDeg) ||
            fovDeg <= 0
          ) {
            return null;
          }
          const adjustedRotation = normalizeDegrees(rotationDeg + 90);
          const halfFov = fovDeg / 2;
          const start = degreesToRadians(adjustedRotation - halfFov);
          const end = degreesToRadians(adjustedRotation + halfFov);
          const steps = Math.max(6, Math.floor(fovDeg / 6));
          const points = [];
          points.push({ x: originX, y: originY });
          points.push({
            x: originX + radius * Math.cos(start),
            y: originY + radius * Math.sin(start),
          });
          for (let i = 1; i <= steps; i += 1) {
            const angle = start + ((end - start) * i) / steps;
            points.push({
              x: originX + radius * Math.cos(angle),
              y: originY + radius * Math.sin(angle),
            });
          }
          points.push({
            x: originX,
            y: originY,
          });
          return {
            type: "scatter",
            mode: "lines",
            line: { color: "#111", width: 1.2, dash: "dot" },
            fill: "toself",
            fillcolor: "rgba(17, 17, 17, 0.08)",
            name: formatLegendLabel(`${label} FOV`),
            meta: { fullLabel: `${label} Field of View` },
            hovertemplate: "<b>%{meta.fullLabel}</b><extra></extra>",
            x: points.map((point) => point.x),
            y: points.map((point) => point.y),
            showlegend: false,
          };
        }

        function resolveShapeStyle(fieldType, shapeType) {
          const normalizedField = String(fieldType || "").toLowerCase();
          const normalizedShape = String(shapeType || "").toLowerCase();
          const isProtective = normalizedField.includes("protective");
          const isWarning = normalizedField.includes("warning");
          const protectiveOrWarning = isProtective || isWarning;

          const style = {
            lineWidth: 1.5,
            lineDash: "solid",
          };

          if (normalizedShape === "field") {
            if (isWarning) {
              style.lineWidth = 1;
              style.lineDash = "solid";
            } else if (isProtective) {
              style.lineWidth = 2;
              style.lineDash = "solid";
            }
          } else if (normalizedShape === "cutout" && protectiveOrWarning) {
            style.lineWidth = 2;
            style.lineDash = "dash";
          }

          return style;
        }

        function formatLegendLabel(label) {
          const text = String(label ?? "").trim();
          if (!text) {
            return "Trace";
          }
          if (text.length <= legendLabelMaxLength) {
            return text;
          }
          return `${text.slice(0, legendLabelMaxLength - 3)}...`;
        }

        function resetFigure() {
          currentFigure = cloneFigure(defaultFigure);
          renderFigure();
          setStatus("Default plot restored.");
        }

        function createDefaultScanPlane(index = scanPlanes.length) {
          return {
            attributes: {
              Index: String(index),
              Name: `Monitoring plane ${index + 1}`,
              ScanPlaneDirection: "Horizontal",
              UseReferenceContour: "false",
              ObjectSize: "70",
              MultipleSampling: "2",
              MultipleSamplingOff2OnActivated: "false",
              SelectedCaseSwitching: "Fast",
            },
            devices: createDefaultScanPlaneDevices(),
          };
        }

        function createDefaultDevice(index = 0, overrides = {}) {
          return {
            attributes: {
              Index: String(index),
              DeviceName: overrides.DeviceName || `Device ${index + 1}`,
              Typekey: overrides.Typekey || "NANS3-CAAZ30ZA1P02",
              TypekeyVersion: overrides.TypekeyVersion || "1.0",
              TypekeyDisplayVersion: overrides.TypekeyDisplayVersion || "V 1.0.0",
              ResponseTime: overrides.ResponseTime || "30",
              ScanResolutionAddition: overrides.ScanResolutionAddition || "0",
            },
          };
        }

        function createDefaultScanPlaneDevices() {
          if (!defaultScanDeviceTemplates.length) {
            return [createDefaultDevice(0)];
          }
          return defaultScanDeviceTemplates.map((template, index) =>
            createDefaultDevice(index, template)
          );
        }

        function renderScanPlanes() {
          if (!scanPlanesContainer) return;
          scanPlanesContainer.innerHTML = scanPlanes
            .map((plane, planeIndex) => {
              const planeFields = Object.entries(plane.attributes || {})
                .map(
                  ([key, value]) => `
              <div class="scanplane-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="scanplane-attr"
                  data-plane-index="${planeIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`
                )
                .join("");

              const deviceCards = (plane.devices || [])
                .map((device, deviceIndex) => {
                  const deviceFields = Object.entries(device.attributes || {})
                    .map(
                      ([key, value]) => `
                  <div class="device-field">
                    <label>${escapeHtml(key)}</label>
                    <input
                      type="text"
                      class="device-attr"
                      data-plane-index="${planeIndex}"
                      data-device-index="${deviceIndex}"
                      data-field="${escapeHtml(key)}"
                      value="${escapeHtml(value ?? "")}"
                    />
                  </div>`
                    )
                    .join("");

                  return `
                <div class="device-card" data-plane-index="${planeIndex}" data-device-index="${deviceIndex}">
                  <details class="device-details" open>
                    <summary>
                      <span>Device #${deviceIndex + 1}</span>
                      <span class="device-summary">${device.attributes.DeviceName || ""}</span>
                      <button
                        type="button"
                        class="inline-btn inline-danger"
                        data-action="remove-device"
                        data-plane-index="${planeIndex}"
                        data-device-index="${deviceIndex}"
                      >
                        Remove
                      </button>
                    </summary>
                    <div class="device-fields">${deviceFields}</div>
                  </details>
                </div>`;
                })
                .join("");

              return `
            <div class="scanplane-card" data-plane-index="${planeIndex}">
              <details class="scanplane-details" open>
                <summary>
                  <span>ScanPlane #${planeIndex + 1}</span>
                  <span class="scanplane-summary">${plane.attributes.Name || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-scanplane"
                    data-plane-index="${planeIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="scanplane-fields">${planeFields}</div>
                <div class="scanplane-devices">
                  ${deviceCards || "<p>No devices yet.</p>"}
                  <div class="scanplane-actions">
                    <button
                      type="button"
                      class="inline-btn add-device-btn"
                      data-action="add-device"
                      data-plane-index="${planeIndex}"
                    >
                      + Device
                    </button>
                  </div>
                </div>
              </details>
            </div>`;
            })
            .join("");
        }

        function ensureDefaultScanDevices(plane) {
          if (!plane) {
            return;
          }
          plane.devices = Array.isArray(plane.devices) ? plane.devices : [];
          const existingNames = new Set(
            plane.devices
              .map((device) => (device.attributes?.DeviceName || "").toLowerCase())
              .filter(Boolean)
          );
          defaultScanDeviceTemplates.forEach((template) => {
            const templateName = (template.DeviceName || "").toLowerCase();
            if (templateName && !existingNames.has(templateName)) {
              const newDevice = createDefaultDevice(plane.devices.length, template);
              plane.devices.push(newDevice);
              existingNames.add(templateName);
            }
          });
        }

        function updateScanPlaneAttribute(planeIndex, field, value) {
          if (scanPlanes[planeIndex]) {
            scanPlanes[planeIndex].attributes[field] = value;
            if (field === "Name") {
              const summary = document.querySelector(
                `.scanplane-card[data-plane-index="${planeIndex}"] .scanplane-summary`
              );
              if (summary) {
                summary.textContent = value;
              }
            }
          }
        }

        function updateDeviceAttribute(planeIndex, deviceIndex, field, value) {
          const plane = scanPlanes[planeIndex];
          if (plane && plane.devices && plane.devices[deviceIndex]) {
            plane.devices[deviceIndex].attributes[field] = value;
            if (field === "DeviceName") {
              const deviceSummary = document.querySelector(
                `.device-card[data-plane-index="${planeIndex}"][data-device-index="${deviceIndex}"] .device-summary`
              );
              if (deviceSummary) {
                deviceSummary.textContent = value;
              }
            }
          }
        }

        function getScanPlaneDeviceOptions() {
          const options = [];
          const seen = new Set();
          scanPlanes.forEach((plane) => {
            (plane.devices || []).forEach((device) => {
              const attrs = device.attributes || {};
              const typekey = attrs.Typekey;
              if (!typekey) {
                return;
              }
              if (seen.has(typekey)) {
                return;
              }
              seen.add(typekey);
              options.push({
                typekey,
                typekeyDisplayVersion: attrs.TypekeyDisplayVersion || "",
                typekeyVersion: attrs.TypekeyVersion || "",
                label: attrs.DeviceName
                  ? `${attrs.DeviceName} (${typekey})`
                  : typekey,
              });
            });
          });
          return options;
        }

        function findScanPlaneDeviceByTypekey(typekey) {
          if (!typekey) {
            return null;
          }
          for (const plane of scanPlanes) {
            for (const device of plane.devices || []) {
              if ((device.attributes || {}).Typekey === typekey) {
                return device;
              }
            }
          }
          return null;
        }

        function applyScanPlaneDeviceAttributes(targetDevice, typekey) {
          targetDevice.attributes = targetDevice.attributes || {};
          targetDevice.attributes.Typekey = typekey || "";

          const source = findScanPlaneDeviceByTypekey(typekey);
          const keys = ["TypekeyDisplayVersion", "TypekeyVersion"];
          keys.forEach((key) => {
            targetDevice.attributes[key] =
              (source?.attributes || {})[key] || "";
          });
        }

        function initializeFieldsets(data) {
          if (!Array.isArray(data) || !data.length) {
            return [createDefaultFieldset(0)];
          }
          return data.map((fieldset, index) => ({
            attributes: {
              Name: fieldset.attributes?.Name || `Fieldset ${index + 1}`,
              ...fieldset.attributes,
            },
            fields: Array.isArray(fieldset.fields) && fieldset.fields.length
              ? fieldset.fields.map((field, fieldIndex) => ({
                  attributes: {
                    Name: field.attributes?.Name || `Field ${fieldIndex + 1}`,
                    ...field.attributes,
                  },
                  polygons: Array.isArray(field.polygons)
                    ? field.polygons.map((polygon) => ({
                        attributes: { ...polygon.attributes },
                        points: Array.isArray(polygon.points)
                          ? polygon.points.map((point) => ({ ...point }))
                          : [],
                      }))
                    : [],
                  circles: Array.isArray(field.circles)
                    ? field.circles.map((circle) => ({ ...circle }))
                    : [],
                  rectangles: Array.isArray(field.rectangles)
                    ? field.rectangles.map((rectangle) => ({ ...rectangle }))
                    : [],
                }))
              : [createDefaultField(0)],
            visible: fieldset.visible !== false,
          }));
        }

        function createDefaultFieldset(index = fieldsets.length) {
          const isFirst = index === 0;
          return {
            attributes: {
              Name: isFirst ? "Default" : `Fieldset ${index + 1}`,
              NameLatin9Key: `FS_DEFAULT_${index + 1}`,
            },
            fields: [createDefaultField(0)],
            visible: true,
          };
        }

        function createDefaultField(index = 0) {
          const samplingValue =
            typeof globalMultipleSampling === "undefined"
              ? "2"
              : globalMultipleSampling;
          return {
            attributes: {
              Name: `Field ${index + 1}`,
              Fieldtype: "ProtectiveSafeBlanking",
              MultipleSampling: samplingValue,
              Resolution: "70",
              TolerancePositive: "0",
              ToleranceNegative: "0",
            },
            polygons: [createDefaultPolygon()],
            circles: [createDefaultCircle()],
            rectangles: [createDefaultRectangle()],
          };
        }

        function deriveInitialMultipleSampling(fieldsetList) {
          for (const fieldset of fieldsetList) {
            if (!fieldset.fields) continue;
            for (const field of fieldset.fields) {
              if (field.attributes?.MultipleSampling) {
                return field.attributes.MultipleSampling;
              }
            }
          }
          return "2";
        }

        function deriveFieldAttribute(fieldsetList, key, fallback) {
          for (const fieldset of fieldsetList) {
            if (!fieldset.fields) continue;
            for (const field of fieldset.fields) {
              if (field.attributes && key in field.attributes) {
                return parseNumeric(field.attributes[key], fallback);
              }
            }
          }
          return fallback;
        }

        function applyGlobalMultipleSampling(value, { rerender = true } = {}) {
          globalMultipleSampling = value;
          if (globalMultipleSamplingInput) {
            globalMultipleSamplingInput.value = value;
          }
          updateGlobalFieldAttributes();
          if (rerender) {
            renderFieldsets();
          }
        }

        function createDefaultPolygon() {
          return {
            attributes: { Type: "CutOut" },
            points: [
              { X: "0", Y: "0" },
              { X: "100", Y: "0" },
              { X: "100", Y: "100" },
              { X: "0", Y: "100" },
            ],
          };
        }

        function createDefaultRectangle() {
          return {
            Type: "Field",
            OriginX: "0",
            OriginY: "0",
            Height: "100",
            Width: "100",
            Rotation: "0",
          };
        }

        function createDefaultCircle() {
          return {
            Type: "Field",
            CenterX: "0",
            CenterY: "0",
            Radius: "100",
          };
        }

        function renderFieldsets() {
          if (!fieldsetsContainer) {
            return;
          }
          const detailState = captureFieldsetDetailState();
          if (!fieldsets.length) {
            fieldsetsContainer.innerHTML = "<p>No fieldsets defined.</p>";
            return;
          }
          fieldsetsContainer.innerHTML = fieldsets
            .map((fieldset, fieldsetIndex) => {
              const fieldsetFields = Object.entries(fieldset.attributes || {})
                .map(([key, value]) => formatFieldsetAttribute(fieldsetIndex, key, value))
                .join("");

              const fieldCards = (fieldset.fields || [])
                .map((field, fieldIndex) => {
                  const fieldAttrs = Object.entries(field.attributes || {})
                    .map(([key, value]) => {
                      if (key === "Fieldtype") {
                        const options = [
                          "ProtectiveSafeBlanking",
                          "WarningSafeBlanking",
                        ]
                          .map(
                            (opt) =>
                              `<option value="${opt}"${
                                opt === value ? " selected" : ""
                              }>${opt}</option>`
                          )
                          .join("");
                        return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <select
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                >
                  ${options}
                </select>
              </div>`;
                      }
                      if (key === "MultipleSampling") {
                        return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <input
                  type="number"
                  value="${escapeHtml(globalMultipleSampling)}"
                  min="2"
                  max="16"
                  readonly
                />
              </div>`;
                      }
                      return formatFieldAttribute(fieldsetIndex, fieldIndex, key, value);
                    })
                    .join("");

                  const polygons =
                    (field.polygons || [])
                      .map((polygon, polygonIndex) =>
                        renderPolygonEditor(fieldsetIndex, fieldIndex, polygon, polygonIndex)
                      )
                      .join("") || "<p>No polygon data.</p>";

                  const circles =
                    (field.circles || [])
                      .map((circle, circleIndex) =>
                        renderCircleEditor(fieldsetIndex, fieldIndex, circle, circleIndex)
                      )
                      .join("") || "<p>No circle data.</p>";

                  const rectangles =
                    (field.rectangles || [])
                      .map((rectangle, rectangleIndex) =>
                        renderRectangleEditor(fieldsetIndex, fieldIndex, rectangle, rectangleIndex)
                      )
                      .join("") || "<p>No rectangle data.</p>";

                  return `
            <div
              class="field-card"
              data-fieldset-index="${fieldsetIndex}"
              data-field-index="${fieldIndex}"
            >
              <details class="field-details" open>
                <summary>
                  <span>Field #${fieldIndex + 1}</span>
                  <span class="field-summary">${field.attributes.Name || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-field"
                    data-fieldset-index="${fieldsetIndex}"
                    data-field-index="${fieldIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="field-attributes">${fieldAttrs}</div>
                <div class="shape-section">
                  <h4>Polygons</h4>
                  <div class="shape-list">${polygons}</div>
                  <div class="shape-actions">
                    <button
                      type="button"
                      class="inline-btn"
                      data-action="add-polygon"
                      data-fieldset-index="${fieldsetIndex}"
                      data-field-index="${fieldIndex}"
                    >
                      + Polygon
                    </button>
                  </div>
                </div>
                <div class="shape-section">
                  <h4>Circles</h4>
                  <div class="shape-list">${circles}</div>
                  <div class="shape-actions">
                    <button
                      type="button"
                      class="inline-btn"
                      data-action="add-circle"
                      data-fieldset-index="${fieldsetIndex}"
                      data-field-index="${fieldIndex}"
                    >
                      + Circle
                    </button>
                  </div>
                </div>
                <div class="shape-section">
                  <h4>Rectangles</h4>
                  <div class="shape-list">${rectangles}</div>
                  <div class="shape-actions">
                    <button
                      type="button"
                      class="inline-btn"
                      data-action="add-rectangle"
                      data-fieldset-index="${fieldsetIndex}"
                      data-field-index="${fieldIndex}"
                    >
                      + Rectangle
                    </button>
                  </div>
                </div>
              </details>
            </div>`;
                })
                .join("") || "<p>No fields defined.</p>";

              return `
          <div class="fieldset-card" data-fieldset-index="${fieldsetIndex}">
            <details class="fieldset-details">
              <summary>
                <span>Fieldset #${fieldsetIndex + 1}</span>
                <span class="fieldset-summary">${fieldset.attributes.Name || ""}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger"
                  data-action="remove-fieldset"
                  data-fieldset-index="${fieldsetIndex}"
                >
                  Remove
                </button>
              </summary>
              <div class="fieldset-fields">${fieldsetFields}</div>
              <div class="field-card-list">
                ${fieldCards}
                <div class="field-actions">
                  <button
                    type="button"
                    class="inline-btn"
                    data-action="add-field"
                    data-fieldset-index="${fieldsetIndex}"
                  >
                    + Field
                  </button>
                </div>
              </div>
            </details>
          </div>`;
            })
            .join("");
          renderFieldsetCheckboxes();
          renderFigure();
          restoreFieldsetDetailState(detailState);
        }

        function formatFieldsetAttribute(fieldsetIndex, key, value) {
          return `
              <div class="fieldset-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="fieldset-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
        }

        function formatFieldAttribute(fieldsetIndex, fieldIndex, key, value) {
          const debugOnly =
            key === "MultipleSampling" ||
            key === "Resolution" ||
            key === "TolerancePositive" ||
            key === "ToleranceNegative";
          if (debugOnly && !debugMode) {
            return "";
          }
          const hiddenClass = debugOnly ? "field-attribute debug-hidden" : "field-attribute";
          if (key === "Fieldtype") {
            const options = [
              "ProtectiveSafeBlanking",
              "WarningSafeBlanking",
            ]
              .map(
                (opt) =>
                  `<option value="${opt}"${
                    opt === value ? " selected" : ""
                  }>${opt}</option>`
              )
              .join("");
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <select
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                >
                  ${options}
                </select>
              </div>`;
          }
          if (key === "MultipleSampling") {
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input
                  type="number"
                  value="${escapeHtml(globalMultipleSampling)}"
                  min="2"
                  max="16"
                  readonly
                />
              </div>`;
          }
          if (key === "Resolution") {
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input
                  type="number"
                  value="${escapeHtml(String(globalResolution))}"
                  readonly
                />
              </div>`;
          }
          if (key === "TolerancePositive" || key === "ToleranceNegative") {
            const boundValue =
              key === "TolerancePositive"
                ? globalTolerancePositive
                : globalToleranceNegative;
            return `
              <div class="${hiddenClass}">
                <label>${escapeHtml(key)}</label>
                <input
                  type="number"
                  value="${escapeHtml(String(boundValue))}"
                  readonly
                />
              </div>`;
          }
          return `
              <div class="field-attribute">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="field-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
        }

        function captureFieldsetDetailState() {
          if (!fieldsetsContainer) {
            return { fieldsets: new Set(), fields: new Set() };
          }
          const fieldsetDetails = new Set();
          const fieldDetails = new Set();
          fieldsetsContainer.querySelectorAll(".fieldset-card").forEach((card) => {
            const index = card.dataset.fieldsetIndex;
            const details = card.querySelector("details");
            if (details?.open && typeof index !== "undefined") {
              fieldsetDetails.add(index);
            }
            card.querySelectorAll(".field-card").forEach((fieldCard) => {
              const fieldIndex = fieldCard.dataset.fieldIndex;
              const fieldDetailsEl = fieldCard.querySelector("details");
              if (fieldDetailsEl?.open && typeof index !== "undefined" && typeof fieldIndex !== "undefined") {
                fieldDetails.add(`${index}:${fieldIndex}`);
              }
            });
          });
          return { fieldsets: fieldsetDetails, fields: fieldDetails };
        }

        function restoreFieldsetDetailState(state) {
          if (!state || !fieldsetsContainer) {
            return;
          }
          fieldsetsContainer.querySelectorAll(".fieldset-card").forEach((card) => {
            const index = card.dataset.fieldsetIndex;
            if (state.fieldsets.has(index)) {
              const details = card.querySelector("details");
              if (details) {
                details.open = true;
              }
            }
            card.querySelectorAll(".field-card").forEach((fieldCard) => {
              const fieldIndex = fieldCard.dataset.fieldIndex;
              const key = `${index}:${fieldIndex}`;
              if (state.fields.has(key)) {
                const details = fieldCard.querySelector("details");
                if (details) {
                  details.open = true;
                }
              }
            });
          });
        }

        function updateFieldsetAttribute(fieldsetIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          if (!fieldset) return;
          fieldset.attributes[key] = value;
          if (key === "Name") {
            const summary = document.querySelector(
              `.fieldset-card[data-fieldset-index="${fieldsetIndex}"] .fieldset-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFieldsetCheckboxes();
          renderFigure();
        }

        function renderPolygonEditor(fieldsetIndex, fieldIndex, polygon, polygonIndex) {
          const typeSelect = renderShapeTypeSelect(
            "polygon",
            polygon.attributes?.Type || "CutOut",
            "polygon-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "polygon-index": polygonIndex,
            }
          );
          const pointInputs = (polygon.points || [])
            .map(
              (point, pointIndex) => `
              <div class="shape-point" data-point-index="${pointIndex}">
                <label>X</label>
                <input
                  type="number"
                  class="polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                  data-axis="X"
                  value="${escapeHtml(point.X ?? "0")}"
                />
                <label>Y</label>
                <input
                  type="number"
                  class="polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                  data-axis="Y"
                  value="${escapeHtml(point.Y ?? "0")}"
                />
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                  data-point-index="${pointIndex}"
                >
                  Remove
                </button>
              </div>`
            )
            .join("");
          return `
            <div class="shape-entry" data-shape="polygon">
              <div class="shape-title">
                <span>Polygon #${polygonIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-polygon"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-points">
                ${pointInputs || "<p>No points.</p>"}
              </div>
              <div class="shape-actions">
                <button
                  type="button"
                  class="inline-btn shape-mini-btn"
                  data-action="add-polygon-point"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-polygon-index="${polygonIndex}"
                >
                  + Point
                </button>
              </div>
            </div>`;
        }

        function renderRectangleEditor(fieldsetIndex, fieldIndex, rectangle, rectangleIndex) {
          const typeSelect = renderShapeTypeSelect(
            "rectangle",
            rectangle.Type || "Field",
            "rectangle-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "rectangle-index": rectangleIndex,
            }
          );
          const fields = ["OriginX", "OriginY", "Width", "Height", "Rotation"].map(
            (key) => `
              <div class="shape-field">
                <label>${key}</label>
                <input
                  type="number"
                  class="rectangle-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-rectangle-index="${rectangleIndex}"
                  data-field="${key}"
                  value="${escapeHtml(rectangle[key] ?? "0")}"
                />
              </div>`
          );
          return `
            <div class="shape-entry" data-shape="rectangle">
              <div class="shape-title">
                <span>Rectangle #${rectangleIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-rectangle"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-rectangle-index="${rectangleIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-grid">
                ${fields.join("")}
              </div>
            </div>`;
        }

        function renderCircleEditor(fieldsetIndex, fieldIndex, circle, circleIndex) {
          const typeSelect = renderShapeTypeSelect(
            "circle",
            circle.Type || "Field",
            "circle-type",
            {
              "fieldset-index": fieldsetIndex,
              "field-index": fieldIndex,
              "circle-index": circleIndex,
            }
          );
          const circleFields = ["CenterX", "CenterY", "Radius"].map(
            (key) => `
              <div class="shape-field">
                <label>${key}</label>
                <input
                  type="number"
                  class="circle-attr"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-circle-index="${circleIndex}"
                  data-field="${key}"
                  value="${escapeHtml(circle[key] ?? "0")}"
                />
              </div>`
          );
          return `
            <div class="shape-entry" data-shape="circle">
              <div class="shape-title">
                <span>Circle #${circleIndex + 1}</span>
                <button
                  type="button"
                  class="inline-btn inline-danger shape-mini-btn"
                  data-action="remove-circle"
                  data-fieldset-index="${fieldsetIndex}"
                  data-field-index="${fieldIndex}"
                  data-circle-index="${circleIndex}"
                >
                  Remove
                </button>
              </div>
              <div class="shape-fields">
                <label>Type</label>
                ${typeSelect}
              </div>
              <div class="shape-grid">
                ${circleFields.join("")}
              </div>
            </div>`;
        }

        function renderShapeTypeSelect(kind, currentValue, className, dataAttrs) {
          const options = new Set(shapeTypeOptions[kind] || []);
          if (currentValue) {
            options.add(currentValue);
          }
          const dataAttrString = Object.entries(dataAttrs || {})
            .map(([key, value]) => ` data-${key}="${escapeHtml(String(value))}"`)
            .join("");
          return `
            <select class="${className}"${dataAttrString}>
              ${Array.from(options)
                .map(
                  (option) =>
                    `<option value="${escapeHtml(option)}"${
                      option === currentValue ? " selected" : ""
                    }>${escapeHtml(option)}</option>`
                )
                .join("")}
            </select>`;
        }

        function updateFieldAttribute(fieldsetIndex, fieldIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          if (!field) return;
          field.attributes[key] = value;
          if (key === "Name") {
            const summary = document.querySelector(
              `.field-card[data-fieldset-index="${fieldsetIndex}"][data-field-index="${fieldIndex}"] .field-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFigure();
        }

        function updatePolygonAttribute(fieldsetIndex, fieldIndex, polygonIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon) return;
          polygon.attributes = polygon.attributes || {};
          polygon.attributes[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function updatePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex, axis, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon || !polygon.points || !polygon.points[pointIndex]) {
            return;
          }
          polygon.points[pointIndex][axis] = value;
          renderFieldsets();
          renderFigure();
        }

        function updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const rectangle = field?.rectangles?.[rectangleIndex];
          if (!rectangle) return;
          rectangle[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, key, value) {
          const fieldset = fieldsets[fieldsetIndex];
          const field = fieldset?.fields?.[fieldIndex];
          const circle = field?.circles?.[circleIndex];
          if (!circle) return;
          circle[key] = value;
          renderFieldsets();
          renderFigure();
        }

        function getFieldEntry(fieldsetIndex, fieldIndex) {
          const fieldset = fieldsets[fieldsetIndex];
          if (!fieldset || !fieldset.fields) {
            return null;
          }
          return fieldset.fields[fieldIndex] || null;
        }

        function addPolygon(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.polygons = field.polygons || [];
          field.polygons.push(createDefaultPolygon());
          renderFieldsets();
        }

        function removePolygon(fieldsetIndex, fieldIndex, polygonIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.polygons) return;
          field.polygons.splice(polygonIndex, 1);
          renderFieldsets();
        }

        function addPolygonPoint(fieldsetIndex, fieldIndex, polygonIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon) return;
          polygon.points = polygon.points || [];
          polygon.points.push({ X: "0", Y: "0" });
          renderFieldsets();
        }

        function removePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          const polygon = field?.polygons?.[polygonIndex];
          if (!polygon || !polygon.points) return;
          polygon.points.splice(pointIndex, 1);
          renderFieldsets();
        }

        function addCircle(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.circles = field.circles || [];
          field.circles.push(createDefaultCircle());
          renderFieldsets();
        }

        function removeCircle(fieldsetIndex, fieldIndex, circleIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.circles) return;
          field.circles.splice(circleIndex, 1);
          renderFieldsets();
        }

        function addRectangle(fieldsetIndex, fieldIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field) return;
          field.rectangles = field.rectangles || [];
          field.rectangles.push(createDefaultRectangle());
          renderFieldsets();
        }

        function removeRectangle(fieldsetIndex, fieldIndex, rectangleIndex) {
          const field = getFieldEntry(fieldsetIndex, fieldIndex);
          if (!field || !field.rectangles) return;
          field.rectangles.splice(rectangleIndex, 1);
          renderFieldsets();
        }

        function formatAttributeBadges(attrs) {
          if (!attrs) {
            return "";
          }
          return Object.entries(attrs)
            .map(
              ([key, value]) =>
                `<span>${escapeHtml(key)}=${escapeHtml(value ?? "")}</span>`
            )
            .join("");
        }

        function initializeFieldsetDevices(data) {
          let devices;
          if (!Array.isArray(data) || !data.length) {
            devices = getDefaultFieldsetDevices();
          } else {
            devices = data.map((device, index) => ({
              attributes: {
                DeviceName: device.attributes?.DeviceName || `Device ${index + 1}`,
                ...device.attributes,
              },
            }));
          }
          ensureDefaultFieldsetDevices(devices);
          return devices;
        }

        function initializeGlobalGeometry(data) {
          if (!data || typeof data !== "object" || !Object.keys(data).length) {
            return { UseGlobalGeometry: "false" };
          }
          return { ...data };
        }

        function createDefaultFieldsetDevice(index = 0, overrides = {}) {
          const options = getScanPlaneDeviceOptions();
          const fallbackOption = options[Math.min(index, Math.max(0, options.length - 1))] || options[0];
          const defaultTypekey = fallbackOption?.typekey || "NANS3-CAAZ30ZA1P02";
          const device = {
            attributes: {
              Typekey: defaultTypekey,
              TypekeyVersion: fallbackOption?.typekeyVersion || "1.0",
              TypekeyDisplayVersion: fallbackOption?.typekeyDisplayVersion || "V 1.0.0",
              PositionX: "0",
              PositionY: "0",
              Rotation: "0",
              StandingUpsideDown: "false",
              ...overrides,
            },
          };
          if (defaultTypekey) {
            applyScanPlaneDeviceAttributes(device, defaultTypekey);
          }
          return device;
        }

        function getDefaultFieldsetDevices() {
          if (!defaultFieldsetDeviceTemplates.length) {
            return [createDefaultFieldsetDevice(0)];
          }
          return defaultFieldsetDeviceTemplates.map((template, index) =>
            createDefaultFieldsetDevice(index, template)
          );
        }

        function ensureDefaultFieldsetDevices(devices) {
          if (!Array.isArray(devices)) {
            return;
          }
          defaultFieldsetDeviceTemplates.forEach((template) => {
            const exists = devices.some(
              (device) =>
                device.attributes?.PositionX === template.PositionX &&
                device.attributes?.PositionY === template.PositionY &&
                device.attributes?.Rotation === template.Rotation
            );
            if (!exists) {
              devices.push(createDefaultFieldsetDevice(devices.length, template));
            }
          });
        }

        function renderFieldsetDevices() {
          if (!fieldsetDevicesContainer) return;
          if (!fieldsetDevices.length) {
            fieldsetDevicesContainer.innerHTML = "<p>No devices defined.</p>";
            return;
          }
          const deviceOptions = getScanPlaneDeviceOptions();
          fieldsetDevicesContainer.innerHTML = fieldsetDevices
            .map((device, deviceIndex) => {
              const sanitizedAttributes = Object.entries(device.attributes || {}).filter(
                ([key]) => key !== "DeviceName"
              );
              const deviceFields = sanitizedAttributes
                .map(([key, value]) => {
                  if (key === "Typekey") {
                    const optionsHtml =
                      '<option value="">-- Select Typekey --</option>' +
                      (deviceOptions.length
                        ? deviceOptions
                            .map(
                              (opt) =>
                                `<option value="${escapeHtml(opt.typekey)}"${
                                  opt.typekey === value ? " selected" : ""
                                }>${escapeHtml(opt.label)}</option>`
                            )
                            .join("")
                        : `<option value="${escapeHtml(value || "")}" selected>${escapeHtml(
                            value || ""
                          )}</option>`);
                    return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <select
                  class="fieldset-device-typekey"
                  data-device-index="${deviceIndex}"
                >
                  ${optionsHtml}
                </select>
              </div>`;
                  }
                  if (["TypekeyDisplayVersion", "TypekeyVersion"].includes(key)) {
                    return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input type="text" value="${escapeHtml(value ?? "")}" readonly />
              </div>`;
                  }
                  return `
              <div class="device-field">
                <label>${escapeHtml(key)}</label>
                <input
                  type="text"
                  class="fieldset-device-attr"
                  data-device-index="${deviceIndex}"
                  data-field="${escapeHtml(key)}"
                  value="${escapeHtml(value ?? "")}"
                />
              </div>`;
                })
                .join("");

              return `
            <div class="device-card" data-fieldset-device-index="${deviceIndex}">
              <details class="device-details" open>
                <summary>
                  <span>Device #${deviceIndex + 1}</span>
                  <span class="device-summary">${device.attributes.Typekey || ""}</span>
                  <button
                    type="button"
                    class="inline-btn inline-danger"
                    data-action="remove-fieldset-device"
                    data-device-index="${deviceIndex}"
                  >
                    Remove
                  </button>
                </summary>
                <div class="device-fields">${deviceFields}</div>
              </details>
            </div>`;
            })
            .join("");
        }

        function renderFieldsetGlobal() {
          if (!fieldsetGlobalContainer) return;
          const entries =
            Object.entries(fieldsetGlobalGeometry || {}).length > 0
              ? Object.entries(fieldsetGlobalGeometry)
              : [["UseGlobalGeometry", "false"]];
          fieldsetGlobalContainer.innerHTML = entries
            .map(
              ([key, value]) => `
          <div class="fieldset-field">
            <label>${escapeHtml(key)}</label>
            <input
              type="text"
              class="fieldset-global-attr"
              data-field="${escapeHtml(key)}"
              value="${escapeHtml(value ?? "")}"
            />
          </div>`
            )
            .join("");
        }

        function updateFieldsetDeviceAttribute(deviceIndex, key, value) {
          const device = fieldsetDevices[deviceIndex];
          if (!device) return;
          device.attributes[key] = value;
          if (key === "Typekey") {
            const summary = document.querySelector(
              `.device-card[data-fieldset-device-index="${deviceIndex}"] .device-summary`
            );
            if (summary) {
              summary.textContent = value;
            }
          }
          renderFigure();
        }

        function updateGlobalGeometryAttribute(key, value) {
          fieldsetGlobalGeometry[key] = value;
        }

        function buildXmlFromFigure() {
          const figure = currentFigure || defaultFigure;
          const fileInfoLines = buildFileInfoLines();
          const scanPlaneLines = buildScanPlanesXml();
          const fieldsetLines = buildFieldsetsXml();
          const rootAttrOverrides = {
            ...rootAttributes,
            Timestamp: new Date().toISOString(),
            "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
            "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          };
          const rootAttrText = buildRootAttributes(
            rootAttrOverrides,
            getAttributeOrder("SdImportExport")
          );
          const lines = [
            '<?xml version="1.0" encoding="utf-8"?>',
            rootAttrText ? `<SdImportExport ${rootAttrText}>` : "<SdImportExport>",
            "  <FileInfo>",
            ...fileInfoLines,
            "  </FileInfo>",
            "  <Export_ScanPlanes>",
            ...scanPlaneLines,
            "  </Export_ScanPlanes>",
            "  <Export_FieldsetsAndFields>",
            ...fieldsetLines,
            "  </Export_FieldsetsAndFields>",
            "  <Export_CasetablesAndCases />",
            "</SdImportExport>",
            "",
            "<TriOrb_SICK_SLS_Editor>",
            "  <PlotlyData>",
            "    <Traces>",
          ];

          (figure.data || []).forEach((trace, index) => {
            const name = escapeXml(trace?.name ?? `Trace ${index + 1}`);
            const mode = escapeXml(trace?.mode ?? "lines");
            lines.push(`      <Trace Name="${name}" Mode="${mode}">`);
            const len = Math.min(trace.x?.length || 0, trace.y?.length || 0);
            for (let i = 0; i < len; i += 1) {
              lines.push(`        <Point X="${trace.x[i]}" Y="${trace.y[i]}" />`);
            }
            lines.push("      </Trace>");
          });

          lines.push("    </Traces>");
          lines.push("  </PlotlyData>");
          lines.push("  <TriOrbMenu>");
          lines.push(
            `    <Device FieldOfView="${escapeXml(String(fieldOfViewDegrees || "270"))}" />`
          );
          lines.push(
            `    <Field MultipleSampling="${escapeXml(
              String(globalMultipleSampling || "2")
            )}">`
          );
          lines.push("      <CommonCutOut Name=\"CommonCutOut #1\">");
          lines.push("        <Polygon Name=\"Polygon #1\" />");
          lines.push("        <Circle Name=\"Circle #1\" />");
          lines.push("        <Rectangle Name=\"Rectangle #1\" />");
          lines.push("      </CommonCutOut>");
          lines.push("    </Field>");
          lines.push("  </TriOrbMenu>");
          lines.push("</TriOrb_SICK_SLS_Editor>");
          return lines.join("\n");
        }

        function buildScanPlanesXml() {
          if (!scanPlanes.length) {
            return ["    <!-- ScanPlane not set -->"];
          }
          const lines = [];
          scanPlanes.forEach((plane) => {
            const attrText = buildAttributeString(
              plane.attributes,
              getAttributeOrder("ScanPlane")
            );
            lines.push(`    <ScanPlane${attrText ? " " + attrText : ""}>`);
            if (plane.devices && plane.devices.length) {
              lines.push("      <Devices>");
              plane.devices.forEach((device) => {
                const deviceAttrs = buildAttributeString(
                  device.attributes,
                  getAttributeOrder("Device")
                );
                lines.push(`        <Device${deviceAttrs ? " " + deviceAttrs : ""} />`);
              });
              lines.push("      </Devices>");
            } else {
              lines.push("      <Devices />");
            }
            lines.push("    </ScanPlane>");
          });
          return lines;
        }

        function buildFieldsetsXml() {
          const lines = [];
          lines.push('    <ScanPlane Index="0">');

          lines.push("      <Devices>");
          if (fieldsetDevices.length) {
            fieldsetDevices.forEach((device) => {
              const sanitizedDeviceAttrs = { ...(device.attributes || {}) };
              delete sanitizedDeviceAttrs.DeviceName;
              const deviceAttrs = buildAttributeString(
                sanitizedDeviceAttrs,
                getAttributeOrder("Device")
              );
              lines.push(`        <Device${deviceAttrs ? " " + deviceAttrs : ""} />`);
            });
          } else {
            lines.push("        <!-- No devices -->");
          }
          lines.push("      </Devices>");

          const globalAttr = buildAttributeString(
            fieldsetGlobalGeometry,
            getAttributeOrder("GlobalGeometry")
          );
          lines.push(
            globalAttr
              ? `      <GlobalGeometry ${globalAttr} />`
              : "      <GlobalGeometry />"
          );

          lines.push("      <Fieldsets>");
          if (fieldsets.length) {
            fieldsets.forEach((fieldset) => {
            const attrText = buildAttributeString(
              fieldset.attributes,
              getAttributeOrder("Fieldset")
            );
            lines.push(`        <Fieldset${attrText ? " " + attrText : ""}>`);
            if (fieldset.fields && fieldset.fields.length) {
              fieldset.fields.forEach((field) => {
                const fieldAttrs = buildAttributeString(
                  field.attributes,
                  getAttributeOrder("Field")
                );
                lines.push(`          <Field${fieldAttrs ? " " + fieldAttrs : ""}>`);
                if (field.polygons && field.polygons.length) {
                  field.polygons.forEach((polygon) => {
                    const polygonAttrs = buildAttributeString(
                      polygon.attributes,
                      getAttributeOrder("Polygon")
                    );
                    lines.push(`            <Polygon${polygonAttrs ? " " + polygonAttrs : ""}>`);
                    if (polygon.points && polygon.points.length) {
                      polygon.points.forEach((point) => {
                        const pointAttrs = buildAttributeString(
                          point,
                          getAttributeOrder("Point")
                        );
                        lines.push(`              <Point${pointAttrs ? " " + pointAttrs : ""} />`);
                      });
                    }
                    lines.push("            </Polygon>");
                  });
                }
                if (field.circles && field.circles.length) {
                  field.circles.forEach((circle) => {
                    const circleAttrs = buildAttributeString(
                      circle,
                      getAttributeOrder("Circle")
                    );
                    lines.push(`            <Circle${circleAttrs ? " " + circleAttrs : ""} />`);
                  });
                }
                if (field.rectangles && field.rectangles.length) {
                  field.rectangles.forEach((rectangle) => {
                    const rectAttrs = buildAttributeString(
                      rectangle,
                      getAttributeOrder("Rectangle")
                    );
                    lines.push(`            <Rectangle${rectAttrs ? " " + rectAttrs : ""} />`);
                  });
                  }
                  lines.push("          </Field>");
                });
              } else {
                lines.push("          <!-- No fields -->");
              }
              lines.push("        </Fieldset>");
            });
          } else {
            lines.push("        <!-- No fieldsets -->");
          }
          lines.push("      </Fieldsets>");
          lines.push("    </ScanPlane>");
          return lines;
        }

        function buildAttributeString(attrs, order = []) {
          if (!attrs) return "";
          const keys = Object.keys(attrs);
          const orderedKeys = [];
          const remaining = new Set(keys);
          order.forEach((key) => {
            if (remaining.has(key)) {
              orderedKeys.push(key);
              remaining.delete(key);
            }
          });
          Array.from(remaining)
            .sort()
            .forEach((key) => orderedKeys.push(key));
          return orderedKeys
            .map(
              (key) =>
                `${sanitizeTagName(key)}="${escapeXml(String(attrs[key] ?? ""))}"`
            )
            .join(" ");
        }

        function getAttributeOrder(tag) {
          switch (tag) {
            case "SdImportExport":
              return ["Timestamp", "xmlns:xsd", "xmlns:xsi"];
            case "ScanPlane":
              return [
                "Index",
                "Name",
                "ScanPlaneDirection",
                "UseReferenceContour",
                "ObjectSize",
                "MultipleSampling",
                "MultipleSamplingOff2OnActivated",
                "SelectedCaseSwitching",
              ];
            case "Device":
              return [
                "Index",
                "Typekey",
                "TypekeyVersion",
                "TypekeyDisplayVersion",
                "DeviceName",
                "ResponseTime",
                "ScanResolutionAddition",
                "PositionX",
                "PositionY",
                "Rotation",
                "StandingUpsideDown",
              ];
            case "Fieldset":
              return ["Name", "NameLatin9Key"];
            case "Field":
              return [
                "Name",
                "Fieldtype",
                "MultipleSampling",
                "Resolution",
                "TolerancePositive",
                "ToleranceNegative",
              ];
            case "Polygon":
              return ["Type"];
            case "Rectangle":
              return ["Type", "OriginX", "OriginY", "Height", "Width", "Rotation"];
            case "Circle":
              return ["Type", "CenterX", "CenterY", "Radius"];
            case "Point":
              return ["X", "Y"];
            case "GlobalGeometry":
              return ["UseGlobalGeometry"];
            default:
              return [];
          }
        }

        function downloadXml(xmlString) {
          const blob = new Blob([xmlString], { type: "application/xml" });
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = `plot_${Date.now()}.sgexml`;
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          URL.revokeObjectURL(url);
        }

        function escapeXml(value) {
          return String(value ?? "").replace(/[<>&'\"]/g, (char) => {
            switch (char) {
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case "&":
                return "&amp;";
              case "'":
                return "&apos;";
              case "\"":
                return "&quot;";
              default:
                return char;
            }
          });
        }

        function escapeHtml(value) {
          return String(value ?? "").replace(/[&<>"']/g, (char) => {
            switch (char) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              case "'":
                return "&#39;";
              default:
                return char;
            }
          });
        }

        function sanitizeTagName(name) {
          return (name || "Field").replace(/[^\w:.-]/g, "_");
        }

        function buildFileInfoLines() {
          const scope = document.querySelector('[data-scope="fileinfo"]');
          if (!scope) {
            return ["    <!-- FileInfo not set -->"];
          }
          const inputs = Array.from(
            scope.querySelectorAll(
              ".menu-fileinfo-field input, .menu-fileinfo-field textarea"
            )
          );
          if (!inputs.length) {
            return ["    <!-- FileInfo not set -->"];
          }
          return inputs.map((input) => {
            const tag = sanitizeTagName(input.dataset.field || input.id || "Field");
            const rawValue = (input.value || "").trim();
            if (!rawValue) {
              return `    <${tag} />`;
            }
            const value = escapeXml(rawValue);
            return `    <${tag}>${value}</${tag}>`;
          });
        }

        function buildRootAttributes(attrs) {
          if (!attrs || typeof attrs !== "object") {
            return "";
          }
          return Object.entries(attrs)
            .map(
              ([key, value]) =>
                `${sanitizeTagName(key)}="${escapeXml(String(value ?? ""))}"`
            )
            .join(" ");
        }

        function buildRootAttributes(attrs, order = []) {
          if (!attrs || typeof attrs !== "object") {
            return "";
          }
          return buildAttributeString(attrs, order);
        }

        function parseXmlToFigure(xmlText) {
          const parser = new DOMParser();
          let doc = parser.parseFromString(xmlText, "application/xml");
          if (doc.querySelector("parsererror")) {
            const sanitized = xmlText.replace(/<\?xml[^>]*\?>/gi, "").trim();
            const wrapped = `<TriOrbWrapper>${sanitized}</TriOrbWrapper>`;
            doc = parser.parseFromString(wrapped, "application/xml");
          }
          if (doc.querySelector("parsererror")) {
            throw new Error("Failed to parse XML.");
          }

          populateFileInfoFromDoc(doc);
          populateScanPlanesFromDoc(doc);
          populateFieldsetsFromDoc(doc);

          const tracesFromPlotData = parsePlotDataTraces(doc);
          if (tracesFromPlotData.length) {
            return { traces: tracesFromPlotData, warning: "" };
          }

          const polygonTrace = parsePolygonTrace(doc);
          if (polygonTrace.length) {
            return { traces: polygonTrace, warning: "" };
          }

          return {
            traces: [],
            warning: "Plot data was not found; displaying an empty plot.",
          };
        }
        function parsePlotDataTraces(doc) {
          const traces = Array.from(
            doc.querySelectorAll(
              "PlotData > Trace, PlotlyData > Trace, PlotlyData > Traces > Trace, TriOrb_SICK_SLS_Editor > PlotlyData > Traces > Trace"
            )
          );
          return traces.map((traceNode, index) => {
            const points = Array.from(traceNode.getElementsByTagName("Point"));
            const x = [];
            const y = [];
            points.forEach((pt) => {
              const xVal = Number(pt.getAttribute("X"));
              const yVal = Number(pt.getAttribute("Y"));
              if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
                x.push(xVal);
                y.push(yVal);
              }
            });

            return buildTraceFromPoints(
              x,
              y,
              {
                name: traceNode.getAttribute("Name") || `Trace ${index + 1}`,
                mode: traceNode.getAttribute("Mode") || "lines+markers",
              },
              index
            );
          });
        }

        function parsePolygonTrace(doc) {
          const polygon = doc.querySelector("Polygon");
          if (!polygon) {
            return [];
          }

          const points = Array.from(polygon.getElementsByTagName("Point"));
          const x = [];
          const y = [];
          points.forEach((pt) => {
            const xVal = Number(pt.getAttribute("X"));
            const yVal = Number(pt.getAttribute("Y"));
            if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
              x.push(xVal);
              y.push(yVal);
            }
          });

          const polygonTrace = buildTraceFromPoints(
            x,
            y,
            {
              name: polygon.getAttribute("Type") || "Polygon",
              mode: "lines+markers",
              fill: "toself",
            },
            0
          );

          const traces = [polygonTrace];
          if (originTrace) {
            traces.push(cloneTrace(originTrace));
          }
          return traces;
        }
        function populateFileInfoFromDoc(doc) {
          const fileInfoNode = doc.querySelector("FileInfo");
          if (!fileInfoNode) return;
          const inputs = document.querySelectorAll(".menu-fileinfo-field input");
          inputs.forEach((input) => {
            const targetTag = input.dataset.field || sanitizeTagName(input.id || "Field");
            const element = fileInfoNode.getElementsByTagName(targetTag)[0];
            if (element && typeof element.textContent === "string") {
              input.value = element.textContent.trim();
            }
          });
        }

        function populateScanPlanesFromDoc(doc) {
          const planeNodes = doc.querySelectorAll("Export_ScanPlanes > ScanPlane");
          if (!planeNodes.length) {
            return;
          }
          scanPlanes = Array.from(planeNodes).map((planeNode, planeIndex) => {
            const attributes = {};
            Array.from(planeNode.attributes).forEach((attr) => {
              attributes[attr.name] = attr.value;
            });
            if (!("Index" in attributes)) {
              attributes.Index = String(planeIndex);
            }
            const devices = Array.from(planeNode.querySelectorAll("Devices > Device")).map((deviceNode, deviceIndex) => {
              const deviceAttrs = {};
              Array.from(deviceNode.attributes).forEach((attr) => {
                deviceAttrs[attr.name] = attr.value;
              });
              if (!("Index" in deviceAttrs)) {
                deviceAttrs.Index = String(deviceIndex);
              }
              return { attributes: deviceAttrs };
            });
            return { attributes, devices };
          });
          renderScanPlanes();
        }

        function populateFieldsetsFromDoc(doc) {
          const scanPlaneNode = doc.querySelector(
            "Export_FieldsetsAndFields > ScanPlane"
          );
          if (!scanPlaneNode) {
            fieldsets = [createDefaultFieldset(0)];
            fieldsetDevices = [createDefaultFieldsetDevice(0)];
            fieldsetGlobalGeometry = initializeGlobalGeometry({});
            renderFieldsets();
            renderFieldsetDevices();
            renderFieldsetGlobal();
            return;
          }

          const devicesParent = scanPlaneNode.querySelector("Devices");
          if (devicesParent) {
            fieldsetDevices = Array.from(
              devicesParent.querySelectorAll("Device")
            ).map((deviceNode, deviceIndex) => {
              const attrs = {};
              Array.from(deviceNode.attributes).forEach((attr) => {
                attrs[attr.name] = attr.value;
              });
              if (!("DeviceName" in attrs)) {
                attrs.DeviceName = `Device ${deviceIndex + 1}`;
              }
              return { attributes: attrs };
            });
          } else {
            fieldsetDevices = [];
          }

          const globalNode = scanPlaneNode.querySelector("GlobalGeometry");
          fieldsetGlobalGeometry = globalNode
            ? Array.from(globalNode.attributes).reduce((acc, attr) => {
                acc[attr.name] = attr.value;
                return acc;
              }, {})
            : { UseGlobalGeometry: "false" };

          const fieldsetsParent = scanPlaneNode.querySelector("Fieldsets");
          const fieldsetNodes = fieldsetsParent
            ? fieldsetsParent.querySelectorAll("Fieldset")
            : [];

          if (!fieldsetNodes.length) {
            fieldsets = [createDefaultFieldset(0)];
          } else {
          fieldsets = Array.from(fieldsetNodes).map((fieldsetNode, fieldsetIndex) => {
            const attributes = {};
            Array.from(fieldsetNode.attributes).forEach((attr) => {
              attributes[attr.name] = attr.value;
            });
              if (!("Name" in attributes)) {
                attributes.Name = `Fieldset ${fieldsetIndex + 1}`;
              }

              const fieldNodes = Array.from(
                fieldsetNode.querySelectorAll("Field")
              );

              const fields = fieldNodes.map((fieldNode, fieldIndex) => {
                const fieldAttrs = {};
                Array.from(fieldNode.attributes).forEach((attr) => {
                  fieldAttrs[attr.name] = attr.value;
                });
                if (!("Name" in fieldAttrs)) {
                  fieldAttrs.Name = `Field ${fieldIndex + 1}`;
                }

                const polygonNodes = Array.from(
                  fieldNode.querySelectorAll("Polygon")
                );
                const polygons = polygonNodes.map((polygonNode) => {
                  const polygonAttrs = {};
                  Array.from(polygonNode.attributes).forEach((attr) => {
                    polygonAttrs[attr.name] = attr.value;
                  });
                  const pointNodes = Array.from(polygonNode.querySelectorAll("Point"));
                  const points = pointNodes.map((pointNode) => {
                    const pointAttrs = {};
                    Array.from(pointNode.attributes).forEach((attr) => {
                      pointAttrs[attr.name] = attr.value;
                    });
                    return pointAttrs;
                  });
                  return { attributes: polygonAttrs, points };
                });

              const circleNodes = Array.from(
                fieldNode.querySelectorAll("Circle")
              );
              const circles = circleNodes.map((circleNode) => {
                const circleAttrs = {};
                Array.from(circleNode.attributes).forEach((attr) => {
                  circleAttrs[attr.name] = attr.value;
                });
                return circleAttrs;
              });

              const rectangleNodes = Array.from(
                fieldNode.querySelectorAll("Rectangle")
              );
              const rectangles = rectangleNodes.map((rectangleNode) => {
                const rectangleAttrs = {};
                Array.from(rectangleNode.attributes).forEach((attr) => {
                  rectangleAttrs[attr.name] = attr.value;
                });
                return rectangleAttrs;
              });

              return {
                attributes: fieldAttrs,
                polygons,
                circles,
                rectangles,
              };
            });

              return {
                attributes,
                fields,
                visible: true,
              };
            });
          }

          globalMultipleSampling = deriveInitialMultipleSampling(fieldsets);
          if (globalMultipleSamplingInput) {
            globalMultipleSamplingInput.value = globalMultipleSampling;
          }
          applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
          renderFieldsets();
          renderFieldsetDevices();
          renderFieldsetGlobal();
        }

        function findOriginTrace(figure) {
          return figure.data?.find((trace) => {
            const x = trace.x || [];
            const y = trace.y || [];
            return x.length === 1 && y.length === 1 && x[0] === 0 && y[0] === 0;
          });
        }

        function syncPlotSize() {
          if (!plotWrapper) return;
          const width = plotWrapper.clientWidth;
          const computedHeight = Math.max(420, Math.min(900, width * 0.6));
          plotNode.style.height = `${computedHeight}px`;
        }

        if (addScanPlaneBtn) {
          addScanPlaneBtn.addEventListener("click", () => {
            scanPlanes.push(createDefaultScanPlane(scanPlanes.length));
            renderScanPlanes();
          });
        }

        if (scanPlanesContainer) {
          scanPlanesContainer.addEventListener("click", (event) => {
            const addTarget = event.target.closest("[data-action='add-device']");
            if (addTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(addTarget.dataset.planeIndex);
              const plane = scanPlanes[planeIndex];
              if (plane) {
                const newDevice = createDefaultDevice(plane.devices.length);
                plane.devices.push(newDevice);
                renderScanPlanes();
              }
              return;
            }

            const removeDeviceTarget = event.target.closest("[data-action='remove-device']");
            if (removeDeviceTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(removeDeviceTarget.dataset.planeIndex);
              const deviceIndex = Number(removeDeviceTarget.dataset.deviceIndex);
              const plane = scanPlanes[planeIndex];
              if (plane && plane.devices) {
                plane.devices.splice(deviceIndex, 1);
                renderScanPlanes();
              }
              return;
            }

            const removePlaneTarget = event.target.closest("[data-action='remove-scanplane']");
            if (removePlaneTarget) {
              event.preventDefault();
              event.stopPropagation();
              const planeIndex = Number(removePlaneTarget.dataset.planeIndex);
              scanPlanes.splice(planeIndex, 1);
              renderScanPlanes();
            }
          });

          scanPlanesContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("scanplane-attr")) {
              const planeIndex = Number(target.dataset.planeIndex);
              const field = target.dataset.field;
              updateScanPlaneAttribute(planeIndex, field, target.value);
            } else if (target.classList.contains("device-attr")) {
              const planeIndex = Number(target.dataset.planeIndex);
              const deviceIndex = Number(target.dataset.deviceIndex);
              const field = target.dataset.field;
              updateDeviceAttribute(planeIndex, deviceIndex, field, target.value);
            }
          });
        }

        if (addFieldsetBtn) {
          addFieldsetBtn.addEventListener("click", () => {
            fieldsets.push(createDefaultFieldset(fieldsets.length));
            applyGlobalMultipleSampling(globalMultipleSampling, { rerender: false });
            renderFieldsets();
          });
        }

        if (globalMultipleSamplingInput) {
          globalMultipleSamplingInput.addEventListener("input", (event) => {
            let value = parseInt(event.target.value, 10);
            if (Number.isNaN(value)) {
              value = 2;
            }
            value = Math.min(16, Math.max(2, value));
            event.target.value = value;
            applyGlobalMultipleSampling(String(value));
            handleTriOrbFieldChange();
          });
        }

        function updateGlobalFieldAttributes() {
          fieldsets.forEach((fieldset) => {
            (fieldset.fields || []).forEach((field) => {
              field.attributes = field.attributes || {};
              field.attributes.MultipleSampling = String(globalMultipleSampling);
              field.attributes.Resolution = String(globalResolution);
              field.attributes.TolerancePositive = String(globalTolerancePositive);
              field.attributes.ToleranceNegative = String(globalToleranceNegative);
            });
          });
        }

        function handleTriOrbFieldChange() {
          updateGlobalFieldAttributes();
          renderFieldsets();
          renderFigure();
        }

        if (globalResolutionInput) {
          globalResolutionInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalResolution);
            globalResolution = Number.isFinite(value) ? value : globalResolution;
            event.target.value = globalResolution;
            handleTriOrbFieldChange();
          });
        }

        if (globalTolerancePositiveInput) {
          globalTolerancePositiveInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalTolerancePositive);
            globalTolerancePositive = Number.isFinite(value) ? value : globalTolerancePositive;
            event.target.value = globalTolerancePositive;
            handleTriOrbFieldChange();
          });
        }

        if (globalToleranceNegativeInput) {
          globalToleranceNegativeInput.addEventListener("input", (event) => {
            const value = parseNumeric(event.target.value, globalToleranceNegative);
            globalToleranceNegative = Number.isFinite(value) ? value : globalToleranceNegative;
            event.target.value = globalToleranceNegative;
            handleTriOrbFieldChange();
          });
        }

        if (fieldOfViewInput) {
          fieldOfViewInput.addEventListener("input", (event) => {
            const nextValue = parseNumeric(event.target.value, fieldOfViewDegrees);
            if (!Number.isFinite(nextValue)) {
              event.target.value = fieldOfViewDegrees;
              return;
            }
            fieldOfViewDegrees = nextValue;
            event.target.value = fieldOfViewDegrees;
            renderFigure();
          });
        }

        if (addFieldsetDeviceBtn) {
          addFieldsetDeviceBtn.addEventListener("click", () => {
            fieldsetDevices.push(createDefaultFieldsetDevice(fieldsetDevices.length));
            renderFieldsetDevices();
            renderFigure();
          });
        }

        if (fieldsetDevicesContainer) {
          fieldsetDevicesContainer.addEventListener("click", (event) => {
            const removeDevice = event.target.closest("[data-action='remove-fieldset-device']");
            if (removeDevice) {
              event.preventDefault();
              event.stopPropagation();
              const deviceIndex = Number(removeDevice.dataset.deviceIndex);
              fieldsetDevices.splice(deviceIndex, 1);
              renderFieldsetDevices();
              renderFigure();
            }
          });

          fieldsetDevicesContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("fieldset-device-typekey")) {
              const deviceIndex = Number(target.dataset.deviceIndex);
              const selectedTypekey = target.value;
              const device = fieldsetDevices[deviceIndex];
              if (device) {
                applyScanPlaneDeviceAttributes(device, selectedTypekey);
                renderFieldsetDevices();
                renderFigure();
              }
            } else if (target.classList.contains("fieldset-device-attr")) {
              const deviceIndex = Number(target.dataset.deviceIndex);
              const field = target.dataset.field;
              updateFieldsetDeviceAttribute(deviceIndex, field, target.value);
            }
          });
        }

        if (fieldsetGlobalContainer) {
          fieldsetGlobalContainer.addEventListener("input", (event) => {
            const target = event.target;
            if (target.classList.contains("fieldset-global-attr")) {
              const field = target.dataset.field;
              updateGlobalGeometryAttribute(field, target.value);
            }
          });
        }

        function renderFieldsetCheckboxes() {
          if (!fieldsetCheckboxes) {
            return;
          }
          if (!fieldsets.length) {
            fieldsetCheckboxes.innerHTML = "<p>No fieldsets available.</p>";
            return;
          }
          fieldsetCheckboxes.innerHTML = fieldsets
            .map((fieldset, index) => {
              const isVisible = fieldset.visible !== false;
              fieldset.visible = isVisible;
              return `
          <label class="fieldset-checkbox">
            <input
              type="checkbox"
              class="fieldset-filter-checkbox"
              data-fieldset-index="${index}"
              ${isVisible ? "checked" : ""}
            />
            ${escapeHtml(fieldset.attributes?.Name || `Fieldset ${index + 1}`)}
          </label>`;
            })
            .join("");
        }

        if (fieldsetCheckboxes) {
          fieldsetCheckboxes.addEventListener("change", (event) => {
            if (event.target.classList.contains("fieldset-filter-checkbox")) {
              const index = Number(event.target.dataset.fieldsetIndex);
              const checked = event.target.checked;
              if (fieldsets[index]) {
                fieldsets[index].visible = checked;
              }
              setStatus(
                `Fieldset ${fieldsets[index]?.attributes?.Name || index + 1} ${
                  checked ? "checked" : "unchecked"
                }`,
                "warning"
              );
              renderFigure();
            }
          });
        }

        if (checkAllBtn) {
          checkAllBtn.addEventListener("click", () => {
            toggleAllFieldsetCheckboxes(true);
          });
        }

        if (uncheckAllBtn) {
          uncheckAllBtn.addEventListener("click", () => {
            toggleAllFieldsetCheckboxes(false);
          });
        }

        const handleFieldsetInput = (event) => {
          const target = event.target;
          if (!target) return;
          if (target.classList.contains("fieldset-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const field = target.dataset.field;
            updateFieldsetAttribute(fieldsetIndex, field, target.value);
          } else if (target.classList.contains("field-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const field = target.dataset.field;
            updateFieldAttribute(fieldsetIndex, fieldIndex, field, target.value);
          } else if (target.classList.contains("polygon-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const polygonIndex = Number(target.dataset.polygonIndex);
            updatePolygonAttribute(fieldsetIndex, fieldIndex, polygonIndex, "Type", target.value);
          } else if (target.classList.contains("polygon-point")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const polygonIndex = Number(target.dataset.polygonIndex);
            const pointIndex = Number(target.dataset.pointIndex);
            const axis = target.dataset.axis === "Y" ? "Y" : "X";
            updatePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex, axis, target.value);
          } else if (target.classList.contains("rectangle-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const rectangleIndex = Number(target.dataset.rectangleIndex);
            updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, "Type", target.value);
          } else if (target.classList.contains("rectangle-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const rectangleIndex = Number(target.dataset.rectangleIndex);
            const field = target.dataset.field;
            updateRectangleAttribute(fieldsetIndex, fieldIndex, rectangleIndex, field, target.value);
          } else if (target.classList.contains("circle-type")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const circleIndex = Number(target.dataset.circleIndex);
            updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, "Type", target.value);
          } else if (target.classList.contains("circle-attr")) {
            const fieldsetIndex = Number(target.dataset.fieldsetIndex);
            const fieldIndex = Number(target.dataset.fieldIndex);
            const circleIndex = Number(target.dataset.circleIndex);
            const field = target.dataset.field;
            updateCircleAttribute(fieldsetIndex, fieldIndex, circleIndex, field, target.value);
          }
        };

        if (fieldsetsContainer) {
          fieldsetsContainer.addEventListener("click", (event) => {
            const actionTarget = event.target.closest("[data-action]");
            if (!actionTarget) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            const action = actionTarget.dataset.action;
            switch (action) {
              case "remove-fieldset": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                fieldsets.splice(fieldsetIndex, 1);
                renderFieldsets();
                break;
              }
              case "add-field": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldset = fieldsets[fieldsetIndex];
                if (fieldset) {
                  fieldset.fields = fieldset.fields || [];
                  fieldset.fields.push(createDefaultField(fieldset.fields.length));
                  renderFieldsets();
                }
                break;
              }
              case "remove-field": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const fieldset = fieldsets[fieldsetIndex];
                if (fieldset && fieldset.fields) {
                  fieldset.fields.splice(fieldIndex, 1);
                  renderFieldsets();
                }
                break;
              }
              case "add-polygon": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                addPolygon(fieldsetIndex, fieldIndex);
                break;
              }
              case "remove-polygon": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const polygonIndex = Number(actionTarget.dataset.polygonIndex);
                removePolygon(fieldsetIndex, fieldIndex, polygonIndex);
                break;
              }
              case "add-polygon-point": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const polygonIndex = Number(actionTarget.dataset.polygonIndex);
                addPolygonPoint(fieldsetIndex, fieldIndex, polygonIndex);
                break;
              }
              case "remove-polygon-point": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const polygonIndex = Number(actionTarget.dataset.polygonIndex);
                const pointIndex = Number(actionTarget.dataset.pointIndex);
                removePolygonPoint(fieldsetIndex, fieldIndex, polygonIndex, pointIndex);
                break;
              }
              case "add-circle": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                addCircle(fieldsetIndex, fieldIndex);
                break;
              }
              case "remove-circle": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const circleIndex = Number(actionTarget.dataset.circleIndex);
                removeCircle(fieldsetIndex, fieldIndex, circleIndex);
                break;
              }
              case "add-rectangle": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                addRectangle(fieldsetIndex, fieldIndex);
                break;
              }
              case "remove-rectangle": {
                const fieldsetIndex = Number(actionTarget.dataset.fieldsetIndex);
                const fieldIndex = Number(actionTarget.dataset.fieldIndex);
                const rectangleIndex = Number(actionTarget.dataset.rectangleIndex);
                removeRectangle(fieldsetIndex, fieldIndex, rectangleIndex);
                break;
              }
              default:
                break;
            }
          });

          fieldsetsContainer.addEventListener("input", (event) => {
            handleFieldsetInput(event);
          });
          fieldsetsContainer.addEventListener("change", (event) => {
            handleFieldsetInput(event);
          });
        }

        function toggleAllFieldsetCheckboxes(checked) {
          if (!fieldsetCheckboxes) return;
          const boxes = fieldsetCheckboxes.querySelectorAll(".fieldset-filter-checkbox");
          boxes.forEach((box) => {
            box.checked = checked;
            const index = Number(box.dataset.fieldsetIndex);
            if (fieldsets[index]) {
              fieldsets[index].visible = checked;
            }
          });
          setStatus(
            checked ? "All fieldsets checked." : "All fieldsets unchecked.",
            checked ? "ok" : "warning"
          );
          renderFigure();
        }

        document.getElementById("btn-new").addEventListener("click", resetFigure);

        document.getElementById("btn-save").addEventListener("click", () => {
          const xml = buildXmlFromFigure();
          downloadXml(xml);
          setStatus("XML downloaded.");
        });

        if (toggleLegendBtn) {
          toggleLegendBtn.addEventListener("click", () => {
            legendVisible = !legendVisible;
            toggleLegendBtn.textContent = legendVisible ? "Hide Legend" : "Show Legend";
            setStatus(legendVisible ? "Legend visible." : "Legend hidden.", legendVisible ? "ok" : "warning");
            renderFigure();
          });
        }

        fileInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = () => {
            try {
              const { traces, warning } = parseXmlToFigure(reader.result);
              const layout = cloneFigure(defaultFigure).layout;
              currentFigure = { data: traces, layout };
              renderFigure();
              if (warning) {
                setStatus(`${file.name} loaded with warnings: ${warning}`, "warning");
              } else {
                setStatus(`${file.name} loaded.`);
              }
            } catch (error) {
              console.error(error);
              setStatus(error.message || "Failed to load file.", "error");
            } finally {
              fileInput.value = "";
            }
          };
          reader.readAsText(file, "utf-8");
        });

        window.addEventListener("resize", () => {
          syncPlotSize();
          Plotly.Plots.resize(plotNode);
        });

        setupLayoutObservers();
        renderFigure();

        function setupLayoutObservers() {
          if (typeof ResizeObserver === "undefined") {
            return;
          }
          const observer = new ResizeObserver(() => {
            syncPlotSize();
            Plotly.Plots.resize(plotNode);
          });
          const contentArea = document.querySelector(".content-area");
          const sideMenu = document.querySelector(".side-menu");
          if (contentArea) observer.observe(contentArea);
          if (sideMenu) observer.observe(sideMenu);
        }
      });
    </script>
  </body>
</html>
